
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Countries
 * 
 */
export type Countries = $Result.DefaultSelection<Prisma.$CountriesPayload>
/**
 * Model PersonalDetails
 * 
 */
export type PersonalDetails = $Result.DefaultSelection<Prisma.$PersonalDetailsPayload>
/**
 * Model FinancialDetails
 * 
 */
export type FinancialDetails = $Result.DefaultSelection<Prisma.$FinancialDetailsPayload>
/**
 * Model InternetDetails
 * 
 */
export type InternetDetails = $Result.DefaultSelection<Prisma.$InternetDetailsPayload>
/**
 * Model EducationDetails
 * 
 */
export type EducationDetails = $Result.DefaultSelection<Prisma.$EducationDetailsPayload>
/**
 * Model EmploymentDetails
 * 
 */
export type EmploymentDetails = $Result.DefaultSelection<Prisma.$EmploymentDetailsPayload>
/**
 * Model VehicleDetails
 * 
 */
export type VehicleDetails = $Result.DefaultSelection<Prisma.$VehicleDetailsPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Countries
 * const countries = await prisma.countries.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Countries
   * const countries = await prisma.countries.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.countries`: Exposes CRUD operations for the **Countries** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Countries
    * const countries = await prisma.countries.findMany()
    * ```
    */
  get countries(): Prisma.CountriesDelegate<ExtArgs>;

  /**
   * `prisma.personalDetails`: Exposes CRUD operations for the **PersonalDetails** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PersonalDetails
    * const personalDetails = await prisma.personalDetails.findMany()
    * ```
    */
  get personalDetails(): Prisma.PersonalDetailsDelegate<ExtArgs>;

  /**
   * `prisma.financialDetails`: Exposes CRUD operations for the **FinancialDetails** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FinancialDetails
    * const financialDetails = await prisma.financialDetails.findMany()
    * ```
    */
  get financialDetails(): Prisma.FinancialDetailsDelegate<ExtArgs>;

  /**
   * `prisma.internetDetails`: Exposes CRUD operations for the **InternetDetails** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InternetDetails
    * const internetDetails = await prisma.internetDetails.findMany()
    * ```
    */
  get internetDetails(): Prisma.InternetDetailsDelegate<ExtArgs>;

  /**
   * `prisma.educationDetails`: Exposes CRUD operations for the **EducationDetails** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EducationDetails
    * const educationDetails = await prisma.educationDetails.findMany()
    * ```
    */
  get educationDetails(): Prisma.EducationDetailsDelegate<ExtArgs>;

  /**
   * `prisma.employmentDetails`: Exposes CRUD operations for the **EmploymentDetails** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmploymentDetails
    * const employmentDetails = await prisma.employmentDetails.findMany()
    * ```
    */
  get employmentDetails(): Prisma.EmploymentDetailsDelegate<ExtArgs>;

  /**
   * `prisma.vehicleDetails`: Exposes CRUD operations for the **VehicleDetails** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VehicleDetails
    * const vehicleDetails = await prisma.vehicleDetails.findMany()
    * ```
    */
  get vehicleDetails(): Prisma.VehicleDetailsDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Countries: 'Countries',
    PersonalDetails: 'PersonalDetails',
    FinancialDetails: 'FinancialDetails',
    InternetDetails: 'InternetDetails',
    EducationDetails: 'EducationDetails',
    EmploymentDetails: 'EmploymentDetails',
    VehicleDetails: 'VehicleDetails'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "countries" | "personalDetails" | "financialDetails" | "internetDetails" | "educationDetails" | "employmentDetails" | "vehicleDetails"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Countries: {
        payload: Prisma.$CountriesPayload<ExtArgs>
        fields: Prisma.CountriesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CountriesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountriesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CountriesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountriesPayload>
          }
          findFirst: {
            args: Prisma.CountriesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountriesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CountriesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountriesPayload>
          }
          findMany: {
            args: Prisma.CountriesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountriesPayload>[]
          }
          create: {
            args: Prisma.CountriesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountriesPayload>
          }
          createMany: {
            args: Prisma.CountriesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CountriesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountriesPayload>
          }
          update: {
            args: Prisma.CountriesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountriesPayload>
          }
          deleteMany: {
            args: Prisma.CountriesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CountriesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CountriesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountriesPayload>
          }
          aggregate: {
            args: Prisma.CountriesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCountries>
          }
          groupBy: {
            args: Prisma.CountriesGroupByArgs<ExtArgs>
            result: $Utils.Optional<CountriesGroupByOutputType>[]
          }
          count: {
            args: Prisma.CountriesCountArgs<ExtArgs>
            result: $Utils.Optional<CountriesCountAggregateOutputType> | number
          }
        }
      }
      PersonalDetails: {
        payload: Prisma.$PersonalDetailsPayload<ExtArgs>
        fields: Prisma.PersonalDetailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PersonalDetailsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalDetailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PersonalDetailsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalDetailsPayload>
          }
          findFirst: {
            args: Prisma.PersonalDetailsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalDetailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PersonalDetailsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalDetailsPayload>
          }
          findMany: {
            args: Prisma.PersonalDetailsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalDetailsPayload>[]
          }
          create: {
            args: Prisma.PersonalDetailsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalDetailsPayload>
          }
          createMany: {
            args: Prisma.PersonalDetailsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PersonalDetailsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalDetailsPayload>
          }
          update: {
            args: Prisma.PersonalDetailsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalDetailsPayload>
          }
          deleteMany: {
            args: Prisma.PersonalDetailsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PersonalDetailsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PersonalDetailsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonalDetailsPayload>
          }
          aggregate: {
            args: Prisma.PersonalDetailsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePersonalDetails>
          }
          groupBy: {
            args: Prisma.PersonalDetailsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PersonalDetailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.PersonalDetailsCountArgs<ExtArgs>
            result: $Utils.Optional<PersonalDetailsCountAggregateOutputType> | number
          }
        }
      }
      FinancialDetails: {
        payload: Prisma.$FinancialDetailsPayload<ExtArgs>
        fields: Prisma.FinancialDetailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FinancialDetailsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialDetailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FinancialDetailsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialDetailsPayload>
          }
          findFirst: {
            args: Prisma.FinancialDetailsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialDetailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FinancialDetailsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialDetailsPayload>
          }
          findMany: {
            args: Prisma.FinancialDetailsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialDetailsPayload>[]
          }
          create: {
            args: Prisma.FinancialDetailsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialDetailsPayload>
          }
          createMany: {
            args: Prisma.FinancialDetailsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.FinancialDetailsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialDetailsPayload>
          }
          update: {
            args: Prisma.FinancialDetailsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialDetailsPayload>
          }
          deleteMany: {
            args: Prisma.FinancialDetailsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FinancialDetailsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FinancialDetailsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FinancialDetailsPayload>
          }
          aggregate: {
            args: Prisma.FinancialDetailsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFinancialDetails>
          }
          groupBy: {
            args: Prisma.FinancialDetailsGroupByArgs<ExtArgs>
            result: $Utils.Optional<FinancialDetailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.FinancialDetailsCountArgs<ExtArgs>
            result: $Utils.Optional<FinancialDetailsCountAggregateOutputType> | number
          }
        }
      }
      InternetDetails: {
        payload: Prisma.$InternetDetailsPayload<ExtArgs>
        fields: Prisma.InternetDetailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InternetDetailsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InternetDetailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InternetDetailsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InternetDetailsPayload>
          }
          findFirst: {
            args: Prisma.InternetDetailsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InternetDetailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InternetDetailsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InternetDetailsPayload>
          }
          findMany: {
            args: Prisma.InternetDetailsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InternetDetailsPayload>[]
          }
          create: {
            args: Prisma.InternetDetailsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InternetDetailsPayload>
          }
          createMany: {
            args: Prisma.InternetDetailsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.InternetDetailsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InternetDetailsPayload>
          }
          update: {
            args: Prisma.InternetDetailsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InternetDetailsPayload>
          }
          deleteMany: {
            args: Prisma.InternetDetailsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InternetDetailsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InternetDetailsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InternetDetailsPayload>
          }
          aggregate: {
            args: Prisma.InternetDetailsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInternetDetails>
          }
          groupBy: {
            args: Prisma.InternetDetailsGroupByArgs<ExtArgs>
            result: $Utils.Optional<InternetDetailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.InternetDetailsCountArgs<ExtArgs>
            result: $Utils.Optional<InternetDetailsCountAggregateOutputType> | number
          }
        }
      }
      EducationDetails: {
        payload: Prisma.$EducationDetailsPayload<ExtArgs>
        fields: Prisma.EducationDetailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EducationDetailsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationDetailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EducationDetailsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationDetailsPayload>
          }
          findFirst: {
            args: Prisma.EducationDetailsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationDetailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EducationDetailsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationDetailsPayload>
          }
          findMany: {
            args: Prisma.EducationDetailsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationDetailsPayload>[]
          }
          create: {
            args: Prisma.EducationDetailsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationDetailsPayload>
          }
          createMany: {
            args: Prisma.EducationDetailsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EducationDetailsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationDetailsPayload>
          }
          update: {
            args: Prisma.EducationDetailsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationDetailsPayload>
          }
          deleteMany: {
            args: Prisma.EducationDetailsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EducationDetailsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EducationDetailsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EducationDetailsPayload>
          }
          aggregate: {
            args: Prisma.EducationDetailsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEducationDetails>
          }
          groupBy: {
            args: Prisma.EducationDetailsGroupByArgs<ExtArgs>
            result: $Utils.Optional<EducationDetailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.EducationDetailsCountArgs<ExtArgs>
            result: $Utils.Optional<EducationDetailsCountAggregateOutputType> | number
          }
        }
      }
      EmploymentDetails: {
        payload: Prisma.$EmploymentDetailsPayload<ExtArgs>
        fields: Prisma.EmploymentDetailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmploymentDetailsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmploymentDetailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmploymentDetailsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmploymentDetailsPayload>
          }
          findFirst: {
            args: Prisma.EmploymentDetailsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmploymentDetailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmploymentDetailsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmploymentDetailsPayload>
          }
          findMany: {
            args: Prisma.EmploymentDetailsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmploymentDetailsPayload>[]
          }
          create: {
            args: Prisma.EmploymentDetailsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmploymentDetailsPayload>
          }
          createMany: {
            args: Prisma.EmploymentDetailsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EmploymentDetailsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmploymentDetailsPayload>
          }
          update: {
            args: Prisma.EmploymentDetailsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmploymentDetailsPayload>
          }
          deleteMany: {
            args: Prisma.EmploymentDetailsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmploymentDetailsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmploymentDetailsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmploymentDetailsPayload>
          }
          aggregate: {
            args: Prisma.EmploymentDetailsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmploymentDetails>
          }
          groupBy: {
            args: Prisma.EmploymentDetailsGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmploymentDetailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmploymentDetailsCountArgs<ExtArgs>
            result: $Utils.Optional<EmploymentDetailsCountAggregateOutputType> | number
          }
        }
      }
      VehicleDetails: {
        payload: Prisma.$VehicleDetailsPayload<ExtArgs>
        fields: Prisma.VehicleDetailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VehicleDetailsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleDetailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VehicleDetailsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleDetailsPayload>
          }
          findFirst: {
            args: Prisma.VehicleDetailsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleDetailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VehicleDetailsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleDetailsPayload>
          }
          findMany: {
            args: Prisma.VehicleDetailsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleDetailsPayload>[]
          }
          create: {
            args: Prisma.VehicleDetailsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleDetailsPayload>
          }
          createMany: {
            args: Prisma.VehicleDetailsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.VehicleDetailsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleDetailsPayload>
          }
          update: {
            args: Prisma.VehicleDetailsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleDetailsPayload>
          }
          deleteMany: {
            args: Prisma.VehicleDetailsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VehicleDetailsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.VehicleDetailsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehicleDetailsPayload>
          }
          aggregate: {
            args: Prisma.VehicleDetailsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVehicleDetails>
          }
          groupBy: {
            args: Prisma.VehicleDetailsGroupByArgs<ExtArgs>
            result: $Utils.Optional<VehicleDetailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.VehicleDetailsCountArgs<ExtArgs>
            result: $Utils.Optional<VehicleDetailsCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type CountriesCountOutputType
   */

  export type CountriesCountOutputType = {
    PersonalDetails: number
    FinancialDetails: number
    InternetDetails: number
    EducationDetails: number
    EmploymentDetails: number
    VehicleDetails: number
  }

  export type CountriesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    PersonalDetails?: boolean | CountriesCountOutputTypeCountPersonalDetailsArgs
    FinancialDetails?: boolean | CountriesCountOutputTypeCountFinancialDetailsArgs
    InternetDetails?: boolean | CountriesCountOutputTypeCountInternetDetailsArgs
    EducationDetails?: boolean | CountriesCountOutputTypeCountEducationDetailsArgs
    EmploymentDetails?: boolean | CountriesCountOutputTypeCountEmploymentDetailsArgs
    VehicleDetails?: boolean | CountriesCountOutputTypeCountVehicleDetailsArgs
  }

  // Custom InputTypes
  /**
   * CountriesCountOutputType without action
   */
  export type CountriesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountriesCountOutputType
     */
    select?: CountriesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CountriesCountOutputType without action
   */
  export type CountriesCountOutputTypeCountPersonalDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersonalDetailsWhereInput
  }

  /**
   * CountriesCountOutputType without action
   */
  export type CountriesCountOutputTypeCountFinancialDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FinancialDetailsWhereInput
  }

  /**
   * CountriesCountOutputType without action
   */
  export type CountriesCountOutputTypeCountInternetDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InternetDetailsWhereInput
  }

  /**
   * CountriesCountOutputType without action
   */
  export type CountriesCountOutputTypeCountEducationDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EducationDetailsWhereInput
  }

  /**
   * CountriesCountOutputType without action
   */
  export type CountriesCountOutputTypeCountEmploymentDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmploymentDetailsWhereInput
  }

  /**
   * CountriesCountOutputType without action
   */
  export type CountriesCountOutputTypeCountVehicleDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VehicleDetailsWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Countries
   */

  export type AggregateCountries = {
    _count: CountriesCountAggregateOutputType | null
    _avg: CountriesAvgAggregateOutputType | null
    _sum: CountriesSumAggregateOutputType | null
    _min: CountriesMinAggregateOutputType | null
    _max: CountriesMaxAggregateOutputType | null
  }

  export type CountriesAvgAggregateOutputType = {
    CountryID: number | null
  }

  export type CountriesSumAggregateOutputType = {
    CountryID: number | null
  }

  export type CountriesMinAggregateOutputType = {
    CountryID: number | null
    CountryName: string | null
  }

  export type CountriesMaxAggregateOutputType = {
    CountryID: number | null
    CountryName: string | null
  }

  export type CountriesCountAggregateOutputType = {
    CountryID: number
    CountryName: number
    _all: number
  }


  export type CountriesAvgAggregateInputType = {
    CountryID?: true
  }

  export type CountriesSumAggregateInputType = {
    CountryID?: true
  }

  export type CountriesMinAggregateInputType = {
    CountryID?: true
    CountryName?: true
  }

  export type CountriesMaxAggregateInputType = {
    CountryID?: true
    CountryName?: true
  }

  export type CountriesCountAggregateInputType = {
    CountryID?: true
    CountryName?: true
    _all?: true
  }

  export type CountriesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Countries to aggregate.
     */
    where?: CountriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: CountriesOrderByWithRelationInput | CountriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CountriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Countries
    **/
    _count?: true | CountriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CountriesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CountriesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CountriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CountriesMaxAggregateInputType
  }

  export type GetCountriesAggregateType<T extends CountriesAggregateArgs> = {
        [P in keyof T & keyof AggregateCountries]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCountries[P]>
      : GetScalarType<T[P], AggregateCountries[P]>
  }




  export type CountriesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CountriesWhereInput
    orderBy?: CountriesOrderByWithAggregationInput | CountriesOrderByWithAggregationInput[]
    by: CountriesScalarFieldEnum[] | CountriesScalarFieldEnum
    having?: CountriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CountriesCountAggregateInputType | true
    _avg?: CountriesAvgAggregateInputType
    _sum?: CountriesSumAggregateInputType
    _min?: CountriesMinAggregateInputType
    _max?: CountriesMaxAggregateInputType
  }

  export type CountriesGroupByOutputType = {
    CountryID: number
    CountryName: string
    _count: CountriesCountAggregateOutputType | null
    _avg: CountriesAvgAggregateOutputType | null
    _sum: CountriesSumAggregateOutputType | null
    _min: CountriesMinAggregateOutputType | null
    _max: CountriesMaxAggregateOutputType | null
  }

  type GetCountriesGroupByPayload<T extends CountriesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CountriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CountriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CountriesGroupByOutputType[P]>
            : GetScalarType<T[P], CountriesGroupByOutputType[P]>
        }
      >
    >


  export type CountriesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    CountryID?: boolean
    CountryName?: boolean
    PersonalDetails?: boolean | Countries$PersonalDetailsArgs<ExtArgs>
    FinancialDetails?: boolean | Countries$FinancialDetailsArgs<ExtArgs>
    InternetDetails?: boolean | Countries$InternetDetailsArgs<ExtArgs>
    EducationDetails?: boolean | Countries$EducationDetailsArgs<ExtArgs>
    EmploymentDetails?: boolean | Countries$EmploymentDetailsArgs<ExtArgs>
    VehicleDetails?: boolean | Countries$VehicleDetailsArgs<ExtArgs>
    _count?: boolean | CountriesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["countries"]>


  export type CountriesSelectScalar = {
    CountryID?: boolean
    CountryName?: boolean
  }

  export type CountriesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    PersonalDetails?: boolean | Countries$PersonalDetailsArgs<ExtArgs>
    FinancialDetails?: boolean | Countries$FinancialDetailsArgs<ExtArgs>
    InternetDetails?: boolean | Countries$InternetDetailsArgs<ExtArgs>
    EducationDetails?: boolean | Countries$EducationDetailsArgs<ExtArgs>
    EmploymentDetails?: boolean | Countries$EmploymentDetailsArgs<ExtArgs>
    VehicleDetails?: boolean | Countries$VehicleDetailsArgs<ExtArgs>
    _count?: boolean | CountriesCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $CountriesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Countries"
    objects: {
      PersonalDetails: Prisma.$PersonalDetailsPayload<ExtArgs>[]
      FinancialDetails: Prisma.$FinancialDetailsPayload<ExtArgs>[]
      InternetDetails: Prisma.$InternetDetailsPayload<ExtArgs>[]
      EducationDetails: Prisma.$EducationDetailsPayload<ExtArgs>[]
      EmploymentDetails: Prisma.$EmploymentDetailsPayload<ExtArgs>[]
      VehicleDetails: Prisma.$VehicleDetailsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      CountryID: number
      CountryName: string
    }, ExtArgs["result"]["countries"]>
    composites: {}
  }

  type CountriesGetPayload<S extends boolean | null | undefined | CountriesDefaultArgs> = $Result.GetResult<Prisma.$CountriesPayload, S>

  type CountriesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CountriesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CountriesCountAggregateInputType | true
    }

  export interface CountriesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Countries'], meta: { name: 'Countries' } }
    /**
     * Find zero or one Countries that matches the filter.
     * @param {CountriesFindUniqueArgs} args - Arguments to find a Countries
     * @example
     * // Get one Countries
     * const countries = await prisma.countries.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CountriesFindUniqueArgs>(args: SelectSubset<T, CountriesFindUniqueArgs<ExtArgs>>): Prisma__CountriesClient<$Result.GetResult<Prisma.$CountriesPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Countries that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CountriesFindUniqueOrThrowArgs} args - Arguments to find a Countries
     * @example
     * // Get one Countries
     * const countries = await prisma.countries.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CountriesFindUniqueOrThrowArgs>(args: SelectSubset<T, CountriesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CountriesClient<$Result.GetResult<Prisma.$CountriesPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Countries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountriesFindFirstArgs} args - Arguments to find a Countries
     * @example
     * // Get one Countries
     * const countries = await prisma.countries.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CountriesFindFirstArgs>(args?: SelectSubset<T, CountriesFindFirstArgs<ExtArgs>>): Prisma__CountriesClient<$Result.GetResult<Prisma.$CountriesPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Countries that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountriesFindFirstOrThrowArgs} args - Arguments to find a Countries
     * @example
     * // Get one Countries
     * const countries = await prisma.countries.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CountriesFindFirstOrThrowArgs>(args?: SelectSubset<T, CountriesFindFirstOrThrowArgs<ExtArgs>>): Prisma__CountriesClient<$Result.GetResult<Prisma.$CountriesPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Countries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountriesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Countries
     * const countries = await prisma.countries.findMany()
     * 
     * // Get first 10 Countries
     * const countries = await prisma.countries.findMany({ take: 10 })
     * 
     * // Only select the `CountryID`
     * const countriesWithCountryIDOnly = await prisma.countries.findMany({ select: { CountryID: true } })
     * 
     */
    findMany<T extends CountriesFindManyArgs>(args?: SelectSubset<T, CountriesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CountriesPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Countries.
     * @param {CountriesCreateArgs} args - Arguments to create a Countries.
     * @example
     * // Create one Countries
     * const Countries = await prisma.countries.create({
     *   data: {
     *     // ... data to create a Countries
     *   }
     * })
     * 
     */
    create<T extends CountriesCreateArgs>(args: SelectSubset<T, CountriesCreateArgs<ExtArgs>>): Prisma__CountriesClient<$Result.GetResult<Prisma.$CountriesPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Countries.
     * @param {CountriesCreateManyArgs} args - Arguments to create many Countries.
     * @example
     * // Create many Countries
     * const countries = await prisma.countries.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CountriesCreateManyArgs>(args?: SelectSubset<T, CountriesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Countries.
     * @param {CountriesDeleteArgs} args - Arguments to delete one Countries.
     * @example
     * // Delete one Countries
     * const Countries = await prisma.countries.delete({
     *   where: {
     *     // ... filter to delete one Countries
     *   }
     * })
     * 
     */
    delete<T extends CountriesDeleteArgs>(args: SelectSubset<T, CountriesDeleteArgs<ExtArgs>>): Prisma__CountriesClient<$Result.GetResult<Prisma.$CountriesPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Countries.
     * @param {CountriesUpdateArgs} args - Arguments to update one Countries.
     * @example
     * // Update one Countries
     * const countries = await prisma.countries.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CountriesUpdateArgs>(args: SelectSubset<T, CountriesUpdateArgs<ExtArgs>>): Prisma__CountriesClient<$Result.GetResult<Prisma.$CountriesPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Countries.
     * @param {CountriesDeleteManyArgs} args - Arguments to filter Countries to delete.
     * @example
     * // Delete a few Countries
     * const { count } = await prisma.countries.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CountriesDeleteManyArgs>(args?: SelectSubset<T, CountriesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Countries
     * const countries = await prisma.countries.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CountriesUpdateManyArgs>(args: SelectSubset<T, CountriesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Countries.
     * @param {CountriesUpsertArgs} args - Arguments to update or create a Countries.
     * @example
     * // Update or create a Countries
     * const countries = await prisma.countries.upsert({
     *   create: {
     *     // ... data to create a Countries
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Countries we want to update
     *   }
     * })
     */
    upsert<T extends CountriesUpsertArgs>(args: SelectSubset<T, CountriesUpsertArgs<ExtArgs>>): Prisma__CountriesClient<$Result.GetResult<Prisma.$CountriesPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountriesCountArgs} args - Arguments to filter Countries to count.
     * @example
     * // Count the number of Countries
     * const count = await prisma.countries.count({
     *   where: {
     *     // ... the filter for the Countries we want to count
     *   }
     * })
    **/
    count<T extends CountriesCountArgs>(
      args?: Subset<T, CountriesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CountriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CountriesAggregateArgs>(args: Subset<T, CountriesAggregateArgs>): Prisma.PrismaPromise<GetCountriesAggregateType<T>>

    /**
     * Group by Countries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CountriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CountriesGroupByArgs['orderBy'] }
        : { orderBy?: CountriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CountriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCountriesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Countries model
   */
  readonly fields: CountriesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Countries.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CountriesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    PersonalDetails<T extends Countries$PersonalDetailsArgs<ExtArgs> = {}>(args?: Subset<T, Countries$PersonalDetailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonalDetailsPayload<ExtArgs>, T, "findMany"> | Null>
    FinancialDetails<T extends Countries$FinancialDetailsArgs<ExtArgs> = {}>(args?: Subset<T, Countries$FinancialDetailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinancialDetailsPayload<ExtArgs>, T, "findMany"> | Null>
    InternetDetails<T extends Countries$InternetDetailsArgs<ExtArgs> = {}>(args?: Subset<T, Countries$InternetDetailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InternetDetailsPayload<ExtArgs>, T, "findMany"> | Null>
    EducationDetails<T extends Countries$EducationDetailsArgs<ExtArgs> = {}>(args?: Subset<T, Countries$EducationDetailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EducationDetailsPayload<ExtArgs>, T, "findMany"> | Null>
    EmploymentDetails<T extends Countries$EmploymentDetailsArgs<ExtArgs> = {}>(args?: Subset<T, Countries$EmploymentDetailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmploymentDetailsPayload<ExtArgs>, T, "findMany"> | Null>
    VehicleDetails<T extends Countries$VehicleDetailsArgs<ExtArgs> = {}>(args?: Subset<T, Countries$VehicleDetailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehicleDetailsPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Countries model
   */ 
  interface CountriesFieldRefs {
    readonly CountryID: FieldRef<"Countries", 'Int'>
    readonly CountryName: FieldRef<"Countries", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Countries findUnique
   */
  export type CountriesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Countries
     */
    select?: CountriesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountriesInclude<ExtArgs> | null
    /**
     * Filter, which Countries to fetch.
     */
    where: CountriesWhereUniqueInput
  }

  /**
   * Countries findUniqueOrThrow
   */
  export type CountriesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Countries
     */
    select?: CountriesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountriesInclude<ExtArgs> | null
    /**
     * Filter, which Countries to fetch.
     */
    where: CountriesWhereUniqueInput
  }

  /**
   * Countries findFirst
   */
  export type CountriesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Countries
     */
    select?: CountriesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountriesInclude<ExtArgs> | null
    /**
     * Filter, which Countries to fetch.
     */
    where?: CountriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: CountriesOrderByWithRelationInput | CountriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Countries.
     */
    cursor?: CountriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Countries.
     */
    distinct?: CountriesScalarFieldEnum | CountriesScalarFieldEnum[]
  }

  /**
   * Countries findFirstOrThrow
   */
  export type CountriesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Countries
     */
    select?: CountriesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountriesInclude<ExtArgs> | null
    /**
     * Filter, which Countries to fetch.
     */
    where?: CountriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: CountriesOrderByWithRelationInput | CountriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Countries.
     */
    cursor?: CountriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Countries.
     */
    distinct?: CountriesScalarFieldEnum | CountriesScalarFieldEnum[]
  }

  /**
   * Countries findMany
   */
  export type CountriesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Countries
     */
    select?: CountriesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountriesInclude<ExtArgs> | null
    /**
     * Filter, which Countries to fetch.
     */
    where?: CountriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Countries to fetch.
     */
    orderBy?: CountriesOrderByWithRelationInput | CountriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Countries.
     */
    cursor?: CountriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Countries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Countries.
     */
    skip?: number
    distinct?: CountriesScalarFieldEnum | CountriesScalarFieldEnum[]
  }

  /**
   * Countries create
   */
  export type CountriesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Countries
     */
    select?: CountriesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountriesInclude<ExtArgs> | null
    /**
     * The data needed to create a Countries.
     */
    data: XOR<CountriesCreateInput, CountriesUncheckedCreateInput>
  }

  /**
   * Countries createMany
   */
  export type CountriesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Countries.
     */
    data: CountriesCreateManyInput | CountriesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Countries update
   */
  export type CountriesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Countries
     */
    select?: CountriesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountriesInclude<ExtArgs> | null
    /**
     * The data needed to update a Countries.
     */
    data: XOR<CountriesUpdateInput, CountriesUncheckedUpdateInput>
    /**
     * Choose, which Countries to update.
     */
    where: CountriesWhereUniqueInput
  }

  /**
   * Countries updateMany
   */
  export type CountriesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Countries.
     */
    data: XOR<CountriesUpdateManyMutationInput, CountriesUncheckedUpdateManyInput>
    /**
     * Filter which Countries to update
     */
    where?: CountriesWhereInput
  }

  /**
   * Countries upsert
   */
  export type CountriesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Countries
     */
    select?: CountriesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountriesInclude<ExtArgs> | null
    /**
     * The filter to search for the Countries to update in case it exists.
     */
    where: CountriesWhereUniqueInput
    /**
     * In case the Countries found by the `where` argument doesn't exist, create a new Countries with this data.
     */
    create: XOR<CountriesCreateInput, CountriesUncheckedCreateInput>
    /**
     * In case the Countries was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CountriesUpdateInput, CountriesUncheckedUpdateInput>
  }

  /**
   * Countries delete
   */
  export type CountriesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Countries
     */
    select?: CountriesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountriesInclude<ExtArgs> | null
    /**
     * Filter which Countries to delete.
     */
    where: CountriesWhereUniqueInput
  }

  /**
   * Countries deleteMany
   */
  export type CountriesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Countries to delete
     */
    where?: CountriesWhereInput
  }

  /**
   * Countries.PersonalDetails
   */
  export type Countries$PersonalDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalDetails
     */
    select?: PersonalDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalDetailsInclude<ExtArgs> | null
    where?: PersonalDetailsWhereInput
    orderBy?: PersonalDetailsOrderByWithRelationInput | PersonalDetailsOrderByWithRelationInput[]
    cursor?: PersonalDetailsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PersonalDetailsScalarFieldEnum | PersonalDetailsScalarFieldEnum[]
  }

  /**
   * Countries.FinancialDetails
   */
  export type Countries$FinancialDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialDetails
     */
    select?: FinancialDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialDetailsInclude<ExtArgs> | null
    where?: FinancialDetailsWhereInput
    orderBy?: FinancialDetailsOrderByWithRelationInput | FinancialDetailsOrderByWithRelationInput[]
    cursor?: FinancialDetailsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FinancialDetailsScalarFieldEnum | FinancialDetailsScalarFieldEnum[]
  }

  /**
   * Countries.InternetDetails
   */
  export type Countries$InternetDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InternetDetails
     */
    select?: InternetDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InternetDetailsInclude<ExtArgs> | null
    where?: InternetDetailsWhereInput
    orderBy?: InternetDetailsOrderByWithRelationInput | InternetDetailsOrderByWithRelationInput[]
    cursor?: InternetDetailsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InternetDetailsScalarFieldEnum | InternetDetailsScalarFieldEnum[]
  }

  /**
   * Countries.EducationDetails
   */
  export type Countries$EducationDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationDetails
     */
    select?: EducationDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationDetailsInclude<ExtArgs> | null
    where?: EducationDetailsWhereInput
    orderBy?: EducationDetailsOrderByWithRelationInput | EducationDetailsOrderByWithRelationInput[]
    cursor?: EducationDetailsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EducationDetailsScalarFieldEnum | EducationDetailsScalarFieldEnum[]
  }

  /**
   * Countries.EmploymentDetails
   */
  export type Countries$EmploymentDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmploymentDetails
     */
    select?: EmploymentDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmploymentDetailsInclude<ExtArgs> | null
    where?: EmploymentDetailsWhereInput
    orderBy?: EmploymentDetailsOrderByWithRelationInput | EmploymentDetailsOrderByWithRelationInput[]
    cursor?: EmploymentDetailsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmploymentDetailsScalarFieldEnum | EmploymentDetailsScalarFieldEnum[]
  }

  /**
   * Countries.VehicleDetails
   */
  export type Countries$VehicleDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleDetails
     */
    select?: VehicleDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleDetailsInclude<ExtArgs> | null
    where?: VehicleDetailsWhereInput
    orderBy?: VehicleDetailsOrderByWithRelationInput | VehicleDetailsOrderByWithRelationInput[]
    cursor?: VehicleDetailsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VehicleDetailsScalarFieldEnum | VehicleDetailsScalarFieldEnum[]
  }

  /**
   * Countries without action
   */
  export type CountriesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Countries
     */
    select?: CountriesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CountriesInclude<ExtArgs> | null
  }


  /**
   * Model PersonalDetails
   */

  export type AggregatePersonalDetails = {
    _count: PersonalDetailsCountAggregateOutputType | null
    _avg: PersonalDetailsAvgAggregateOutputType | null
    _sum: PersonalDetailsSumAggregateOutputType | null
    _min: PersonalDetailsMinAggregateOutputType | null
    _max: PersonalDetailsMaxAggregateOutputType | null
  }

  export type PersonalDetailsAvgAggregateOutputType = {
    ID: number | null
    Age: number | null
    Height: number | null
    Weight: number | null
    CountryID: number | null
  }

  export type PersonalDetailsSumAggregateOutputType = {
    ID: number | null
    Age: number | null
    Height: number | null
    Weight: number | null
    CountryID: number | null
  }

  export type PersonalDetailsMinAggregateOutputType = {
    ID: number | null
    Name: string | null
    Address: string | null
    Postcode: string | null
    City: string | null
    DateOfBirth: Date | null
    Gender: string | null
    Phone: string | null
    MothersMaidenName: string | null
    Email: string | null
    Ethnicity: string | null
    ZodiacSign: string | null
    Age: number | null
    Height: number | null
    Weight: number | null
    EyeColor: string | null
    HairColor: string | null
    CountryID: number | null
  }

  export type PersonalDetailsMaxAggregateOutputType = {
    ID: number | null
    Name: string | null
    Address: string | null
    Postcode: string | null
    City: string | null
    DateOfBirth: Date | null
    Gender: string | null
    Phone: string | null
    MothersMaidenName: string | null
    Email: string | null
    Ethnicity: string | null
    ZodiacSign: string | null
    Age: number | null
    Height: number | null
    Weight: number | null
    EyeColor: string | null
    HairColor: string | null
    CountryID: number | null
  }

  export type PersonalDetailsCountAggregateOutputType = {
    ID: number
    Name: number
    Address: number
    Postcode: number
    City: number
    DateOfBirth: number
    Gender: number
    Phone: number
    MothersMaidenName: number
    Email: number
    Ethnicity: number
    ZodiacSign: number
    Age: number
    Height: number
    Weight: number
    EyeColor: number
    HairColor: number
    CountryID: number
    _all: number
  }


  export type PersonalDetailsAvgAggregateInputType = {
    ID?: true
    Age?: true
    Height?: true
    Weight?: true
    CountryID?: true
  }

  export type PersonalDetailsSumAggregateInputType = {
    ID?: true
    Age?: true
    Height?: true
    Weight?: true
    CountryID?: true
  }

  export type PersonalDetailsMinAggregateInputType = {
    ID?: true
    Name?: true
    Address?: true
    Postcode?: true
    City?: true
    DateOfBirth?: true
    Gender?: true
    Phone?: true
    MothersMaidenName?: true
    Email?: true
    Ethnicity?: true
    ZodiacSign?: true
    Age?: true
    Height?: true
    Weight?: true
    EyeColor?: true
    HairColor?: true
    CountryID?: true
  }

  export type PersonalDetailsMaxAggregateInputType = {
    ID?: true
    Name?: true
    Address?: true
    Postcode?: true
    City?: true
    DateOfBirth?: true
    Gender?: true
    Phone?: true
    MothersMaidenName?: true
    Email?: true
    Ethnicity?: true
    ZodiacSign?: true
    Age?: true
    Height?: true
    Weight?: true
    EyeColor?: true
    HairColor?: true
    CountryID?: true
  }

  export type PersonalDetailsCountAggregateInputType = {
    ID?: true
    Name?: true
    Address?: true
    Postcode?: true
    City?: true
    DateOfBirth?: true
    Gender?: true
    Phone?: true
    MothersMaidenName?: true
    Email?: true
    Ethnicity?: true
    ZodiacSign?: true
    Age?: true
    Height?: true
    Weight?: true
    EyeColor?: true
    HairColor?: true
    CountryID?: true
    _all?: true
  }

  export type PersonalDetailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PersonalDetails to aggregate.
     */
    where?: PersonalDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonalDetails to fetch.
     */
    orderBy?: PersonalDetailsOrderByWithRelationInput | PersonalDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PersonalDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonalDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonalDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PersonalDetails
    **/
    _count?: true | PersonalDetailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PersonalDetailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PersonalDetailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PersonalDetailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PersonalDetailsMaxAggregateInputType
  }

  export type GetPersonalDetailsAggregateType<T extends PersonalDetailsAggregateArgs> = {
        [P in keyof T & keyof AggregatePersonalDetails]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePersonalDetails[P]>
      : GetScalarType<T[P], AggregatePersonalDetails[P]>
  }




  export type PersonalDetailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersonalDetailsWhereInput
    orderBy?: PersonalDetailsOrderByWithAggregationInput | PersonalDetailsOrderByWithAggregationInput[]
    by: PersonalDetailsScalarFieldEnum[] | PersonalDetailsScalarFieldEnum
    having?: PersonalDetailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PersonalDetailsCountAggregateInputType | true
    _avg?: PersonalDetailsAvgAggregateInputType
    _sum?: PersonalDetailsSumAggregateInputType
    _min?: PersonalDetailsMinAggregateInputType
    _max?: PersonalDetailsMaxAggregateInputType
  }

  export type PersonalDetailsGroupByOutputType = {
    ID: number
    Name: string | null
    Address: string | null
    Postcode: string | null
    City: string | null
    DateOfBirth: Date | null
    Gender: string | null
    Phone: string | null
    MothersMaidenName: string | null
    Email: string | null
    Ethnicity: string | null
    ZodiacSign: string | null
    Age: number | null
    Height: number | null
    Weight: number | null
    EyeColor: string | null
    HairColor: string | null
    CountryID: number
    _count: PersonalDetailsCountAggregateOutputType | null
    _avg: PersonalDetailsAvgAggregateOutputType | null
    _sum: PersonalDetailsSumAggregateOutputType | null
    _min: PersonalDetailsMinAggregateOutputType | null
    _max: PersonalDetailsMaxAggregateOutputType | null
  }

  type GetPersonalDetailsGroupByPayload<T extends PersonalDetailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PersonalDetailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PersonalDetailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PersonalDetailsGroupByOutputType[P]>
            : GetScalarType<T[P], PersonalDetailsGroupByOutputType[P]>
        }
      >
    >


  export type PersonalDetailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    Name?: boolean
    Address?: boolean
    Postcode?: boolean
    City?: boolean
    DateOfBirth?: boolean
    Gender?: boolean
    Phone?: boolean
    MothersMaidenName?: boolean
    Email?: boolean
    Ethnicity?: boolean
    ZodiacSign?: boolean
    Age?: boolean
    Height?: boolean
    Weight?: boolean
    EyeColor?: boolean
    HairColor?: boolean
    CountryID?: boolean
    Country?: boolean | CountriesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["personalDetails"]>


  export type PersonalDetailsSelectScalar = {
    ID?: boolean
    Name?: boolean
    Address?: boolean
    Postcode?: boolean
    City?: boolean
    DateOfBirth?: boolean
    Gender?: boolean
    Phone?: boolean
    MothersMaidenName?: boolean
    Email?: boolean
    Ethnicity?: boolean
    ZodiacSign?: boolean
    Age?: boolean
    Height?: boolean
    Weight?: boolean
    EyeColor?: boolean
    HairColor?: boolean
    CountryID?: boolean
  }

  export type PersonalDetailsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Country?: boolean | CountriesDefaultArgs<ExtArgs>
  }

  export type $PersonalDetailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PersonalDetails"
    objects: {
      Country: Prisma.$CountriesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      ID: number
      Name: string | null
      Address: string | null
      Postcode: string | null
      City: string | null
      DateOfBirth: Date | null
      Gender: string | null
      Phone: string | null
      MothersMaidenName: string | null
      Email: string | null
      Ethnicity: string | null
      ZodiacSign: string | null
      Age: number | null
      Height: number | null
      Weight: number | null
      EyeColor: string | null
      HairColor: string | null
      CountryID: number
    }, ExtArgs["result"]["personalDetails"]>
    composites: {}
  }

  type PersonalDetailsGetPayload<S extends boolean | null | undefined | PersonalDetailsDefaultArgs> = $Result.GetResult<Prisma.$PersonalDetailsPayload, S>

  type PersonalDetailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PersonalDetailsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PersonalDetailsCountAggregateInputType | true
    }

  export interface PersonalDetailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PersonalDetails'], meta: { name: 'PersonalDetails' } }
    /**
     * Find zero or one PersonalDetails that matches the filter.
     * @param {PersonalDetailsFindUniqueArgs} args - Arguments to find a PersonalDetails
     * @example
     * // Get one PersonalDetails
     * const personalDetails = await prisma.personalDetails.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PersonalDetailsFindUniqueArgs>(args: SelectSubset<T, PersonalDetailsFindUniqueArgs<ExtArgs>>): Prisma__PersonalDetailsClient<$Result.GetResult<Prisma.$PersonalDetailsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PersonalDetails that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PersonalDetailsFindUniqueOrThrowArgs} args - Arguments to find a PersonalDetails
     * @example
     * // Get one PersonalDetails
     * const personalDetails = await prisma.personalDetails.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PersonalDetailsFindUniqueOrThrowArgs>(args: SelectSubset<T, PersonalDetailsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PersonalDetailsClient<$Result.GetResult<Prisma.$PersonalDetailsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PersonalDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalDetailsFindFirstArgs} args - Arguments to find a PersonalDetails
     * @example
     * // Get one PersonalDetails
     * const personalDetails = await prisma.personalDetails.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PersonalDetailsFindFirstArgs>(args?: SelectSubset<T, PersonalDetailsFindFirstArgs<ExtArgs>>): Prisma__PersonalDetailsClient<$Result.GetResult<Prisma.$PersonalDetailsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PersonalDetails that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalDetailsFindFirstOrThrowArgs} args - Arguments to find a PersonalDetails
     * @example
     * // Get one PersonalDetails
     * const personalDetails = await prisma.personalDetails.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PersonalDetailsFindFirstOrThrowArgs>(args?: SelectSubset<T, PersonalDetailsFindFirstOrThrowArgs<ExtArgs>>): Prisma__PersonalDetailsClient<$Result.GetResult<Prisma.$PersonalDetailsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PersonalDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalDetailsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PersonalDetails
     * const personalDetails = await prisma.personalDetails.findMany()
     * 
     * // Get first 10 PersonalDetails
     * const personalDetails = await prisma.personalDetails.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const personalDetailsWithIDOnly = await prisma.personalDetails.findMany({ select: { ID: true } })
     * 
     */
    findMany<T extends PersonalDetailsFindManyArgs>(args?: SelectSubset<T, PersonalDetailsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonalDetailsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PersonalDetails.
     * @param {PersonalDetailsCreateArgs} args - Arguments to create a PersonalDetails.
     * @example
     * // Create one PersonalDetails
     * const PersonalDetails = await prisma.personalDetails.create({
     *   data: {
     *     // ... data to create a PersonalDetails
     *   }
     * })
     * 
     */
    create<T extends PersonalDetailsCreateArgs>(args: SelectSubset<T, PersonalDetailsCreateArgs<ExtArgs>>): Prisma__PersonalDetailsClient<$Result.GetResult<Prisma.$PersonalDetailsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PersonalDetails.
     * @param {PersonalDetailsCreateManyArgs} args - Arguments to create many PersonalDetails.
     * @example
     * // Create many PersonalDetails
     * const personalDetails = await prisma.personalDetails.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PersonalDetailsCreateManyArgs>(args?: SelectSubset<T, PersonalDetailsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PersonalDetails.
     * @param {PersonalDetailsDeleteArgs} args - Arguments to delete one PersonalDetails.
     * @example
     * // Delete one PersonalDetails
     * const PersonalDetails = await prisma.personalDetails.delete({
     *   where: {
     *     // ... filter to delete one PersonalDetails
     *   }
     * })
     * 
     */
    delete<T extends PersonalDetailsDeleteArgs>(args: SelectSubset<T, PersonalDetailsDeleteArgs<ExtArgs>>): Prisma__PersonalDetailsClient<$Result.GetResult<Prisma.$PersonalDetailsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PersonalDetails.
     * @param {PersonalDetailsUpdateArgs} args - Arguments to update one PersonalDetails.
     * @example
     * // Update one PersonalDetails
     * const personalDetails = await prisma.personalDetails.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PersonalDetailsUpdateArgs>(args: SelectSubset<T, PersonalDetailsUpdateArgs<ExtArgs>>): Prisma__PersonalDetailsClient<$Result.GetResult<Prisma.$PersonalDetailsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PersonalDetails.
     * @param {PersonalDetailsDeleteManyArgs} args - Arguments to filter PersonalDetails to delete.
     * @example
     * // Delete a few PersonalDetails
     * const { count } = await prisma.personalDetails.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PersonalDetailsDeleteManyArgs>(args?: SelectSubset<T, PersonalDetailsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PersonalDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalDetailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PersonalDetails
     * const personalDetails = await prisma.personalDetails.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PersonalDetailsUpdateManyArgs>(args: SelectSubset<T, PersonalDetailsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PersonalDetails.
     * @param {PersonalDetailsUpsertArgs} args - Arguments to update or create a PersonalDetails.
     * @example
     * // Update or create a PersonalDetails
     * const personalDetails = await prisma.personalDetails.upsert({
     *   create: {
     *     // ... data to create a PersonalDetails
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PersonalDetails we want to update
     *   }
     * })
     */
    upsert<T extends PersonalDetailsUpsertArgs>(args: SelectSubset<T, PersonalDetailsUpsertArgs<ExtArgs>>): Prisma__PersonalDetailsClient<$Result.GetResult<Prisma.$PersonalDetailsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PersonalDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalDetailsCountArgs} args - Arguments to filter PersonalDetails to count.
     * @example
     * // Count the number of PersonalDetails
     * const count = await prisma.personalDetails.count({
     *   where: {
     *     // ... the filter for the PersonalDetails we want to count
     *   }
     * })
    **/
    count<T extends PersonalDetailsCountArgs>(
      args?: Subset<T, PersonalDetailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PersonalDetailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PersonalDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalDetailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PersonalDetailsAggregateArgs>(args: Subset<T, PersonalDetailsAggregateArgs>): Prisma.PrismaPromise<GetPersonalDetailsAggregateType<T>>

    /**
     * Group by PersonalDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonalDetailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PersonalDetailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PersonalDetailsGroupByArgs['orderBy'] }
        : { orderBy?: PersonalDetailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PersonalDetailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPersonalDetailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PersonalDetails model
   */
  readonly fields: PersonalDetailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PersonalDetails.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PersonalDetailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Country<T extends CountriesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CountriesDefaultArgs<ExtArgs>>): Prisma__CountriesClient<$Result.GetResult<Prisma.$CountriesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PersonalDetails model
   */ 
  interface PersonalDetailsFieldRefs {
    readonly ID: FieldRef<"PersonalDetails", 'Int'>
    readonly Name: FieldRef<"PersonalDetails", 'String'>
    readonly Address: FieldRef<"PersonalDetails", 'String'>
    readonly Postcode: FieldRef<"PersonalDetails", 'String'>
    readonly City: FieldRef<"PersonalDetails", 'String'>
    readonly DateOfBirth: FieldRef<"PersonalDetails", 'DateTime'>
    readonly Gender: FieldRef<"PersonalDetails", 'String'>
    readonly Phone: FieldRef<"PersonalDetails", 'String'>
    readonly MothersMaidenName: FieldRef<"PersonalDetails", 'String'>
    readonly Email: FieldRef<"PersonalDetails", 'String'>
    readonly Ethnicity: FieldRef<"PersonalDetails", 'String'>
    readonly ZodiacSign: FieldRef<"PersonalDetails", 'String'>
    readonly Age: FieldRef<"PersonalDetails", 'Int'>
    readonly Height: FieldRef<"PersonalDetails", 'Float'>
    readonly Weight: FieldRef<"PersonalDetails", 'Float'>
    readonly EyeColor: FieldRef<"PersonalDetails", 'String'>
    readonly HairColor: FieldRef<"PersonalDetails", 'String'>
    readonly CountryID: FieldRef<"PersonalDetails", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PersonalDetails findUnique
   */
  export type PersonalDetailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalDetails
     */
    select?: PersonalDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalDetailsInclude<ExtArgs> | null
    /**
     * Filter, which PersonalDetails to fetch.
     */
    where: PersonalDetailsWhereUniqueInput
  }

  /**
   * PersonalDetails findUniqueOrThrow
   */
  export type PersonalDetailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalDetails
     */
    select?: PersonalDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalDetailsInclude<ExtArgs> | null
    /**
     * Filter, which PersonalDetails to fetch.
     */
    where: PersonalDetailsWhereUniqueInput
  }

  /**
   * PersonalDetails findFirst
   */
  export type PersonalDetailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalDetails
     */
    select?: PersonalDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalDetailsInclude<ExtArgs> | null
    /**
     * Filter, which PersonalDetails to fetch.
     */
    where?: PersonalDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonalDetails to fetch.
     */
    orderBy?: PersonalDetailsOrderByWithRelationInput | PersonalDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PersonalDetails.
     */
    cursor?: PersonalDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonalDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonalDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PersonalDetails.
     */
    distinct?: PersonalDetailsScalarFieldEnum | PersonalDetailsScalarFieldEnum[]
  }

  /**
   * PersonalDetails findFirstOrThrow
   */
  export type PersonalDetailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalDetails
     */
    select?: PersonalDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalDetailsInclude<ExtArgs> | null
    /**
     * Filter, which PersonalDetails to fetch.
     */
    where?: PersonalDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonalDetails to fetch.
     */
    orderBy?: PersonalDetailsOrderByWithRelationInput | PersonalDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PersonalDetails.
     */
    cursor?: PersonalDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonalDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonalDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PersonalDetails.
     */
    distinct?: PersonalDetailsScalarFieldEnum | PersonalDetailsScalarFieldEnum[]
  }

  /**
   * PersonalDetails findMany
   */
  export type PersonalDetailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalDetails
     */
    select?: PersonalDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalDetailsInclude<ExtArgs> | null
    /**
     * Filter, which PersonalDetails to fetch.
     */
    where?: PersonalDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonalDetails to fetch.
     */
    orderBy?: PersonalDetailsOrderByWithRelationInput | PersonalDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PersonalDetails.
     */
    cursor?: PersonalDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PersonalDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonalDetails.
     */
    skip?: number
    distinct?: PersonalDetailsScalarFieldEnum | PersonalDetailsScalarFieldEnum[]
  }

  /**
   * PersonalDetails create
   */
  export type PersonalDetailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalDetails
     */
    select?: PersonalDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalDetailsInclude<ExtArgs> | null
    /**
     * The data needed to create a PersonalDetails.
     */
    data: XOR<PersonalDetailsCreateInput, PersonalDetailsUncheckedCreateInput>
  }

  /**
   * PersonalDetails createMany
   */
  export type PersonalDetailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PersonalDetails.
     */
    data: PersonalDetailsCreateManyInput | PersonalDetailsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PersonalDetails update
   */
  export type PersonalDetailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalDetails
     */
    select?: PersonalDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalDetailsInclude<ExtArgs> | null
    /**
     * The data needed to update a PersonalDetails.
     */
    data: XOR<PersonalDetailsUpdateInput, PersonalDetailsUncheckedUpdateInput>
    /**
     * Choose, which PersonalDetails to update.
     */
    where: PersonalDetailsWhereUniqueInput
  }

  /**
   * PersonalDetails updateMany
   */
  export type PersonalDetailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PersonalDetails.
     */
    data: XOR<PersonalDetailsUpdateManyMutationInput, PersonalDetailsUncheckedUpdateManyInput>
    /**
     * Filter which PersonalDetails to update
     */
    where?: PersonalDetailsWhereInput
  }

  /**
   * PersonalDetails upsert
   */
  export type PersonalDetailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalDetails
     */
    select?: PersonalDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalDetailsInclude<ExtArgs> | null
    /**
     * The filter to search for the PersonalDetails to update in case it exists.
     */
    where: PersonalDetailsWhereUniqueInput
    /**
     * In case the PersonalDetails found by the `where` argument doesn't exist, create a new PersonalDetails with this data.
     */
    create: XOR<PersonalDetailsCreateInput, PersonalDetailsUncheckedCreateInput>
    /**
     * In case the PersonalDetails was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PersonalDetailsUpdateInput, PersonalDetailsUncheckedUpdateInput>
  }

  /**
   * PersonalDetails delete
   */
  export type PersonalDetailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalDetails
     */
    select?: PersonalDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalDetailsInclude<ExtArgs> | null
    /**
     * Filter which PersonalDetails to delete.
     */
    where: PersonalDetailsWhereUniqueInput
  }

  /**
   * PersonalDetails deleteMany
   */
  export type PersonalDetailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PersonalDetails to delete
     */
    where?: PersonalDetailsWhereInput
  }

  /**
   * PersonalDetails without action
   */
  export type PersonalDetailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonalDetails
     */
    select?: PersonalDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonalDetailsInclude<ExtArgs> | null
  }


  /**
   * Model FinancialDetails
   */

  export type AggregateFinancialDetails = {
    _count: FinancialDetailsCountAggregateOutputType | null
    _avg: FinancialDetailsAvgAggregateOutputType | null
    _sum: FinancialDetailsSumAggregateOutputType | null
    _min: FinancialDetailsMinAggregateOutputType | null
    _max: FinancialDetailsMaxAggregateOutputType | null
  }

  export type FinancialDetailsAvgAggregateOutputType = {
    ID: number | null
    CreditCardCVV2: number | null
    CountryID: number | null
  }

  export type FinancialDetailsSumAggregateOutputType = {
    ID: number | null
    CreditCardCVV2: number | null
    CountryID: number | null
  }

  export type FinancialDetailsMinAggregateOutputType = {
    ID: number | null
    CreditCardType: string | null
    CreditCardNumber: string | null
    CreditCardExpiry: string | null
    CreditCardCVV2: number | null
    CountryID: number | null
  }

  export type FinancialDetailsMaxAggregateOutputType = {
    ID: number | null
    CreditCardType: string | null
    CreditCardNumber: string | null
    CreditCardExpiry: string | null
    CreditCardCVV2: number | null
    CountryID: number | null
  }

  export type FinancialDetailsCountAggregateOutputType = {
    ID: number
    CreditCardType: number
    CreditCardNumber: number
    CreditCardExpiry: number
    CreditCardCVV2: number
    CountryID: number
    _all: number
  }


  export type FinancialDetailsAvgAggregateInputType = {
    ID?: true
    CreditCardCVV2?: true
    CountryID?: true
  }

  export type FinancialDetailsSumAggregateInputType = {
    ID?: true
    CreditCardCVV2?: true
    CountryID?: true
  }

  export type FinancialDetailsMinAggregateInputType = {
    ID?: true
    CreditCardType?: true
    CreditCardNumber?: true
    CreditCardExpiry?: true
    CreditCardCVV2?: true
    CountryID?: true
  }

  export type FinancialDetailsMaxAggregateInputType = {
    ID?: true
    CreditCardType?: true
    CreditCardNumber?: true
    CreditCardExpiry?: true
    CreditCardCVV2?: true
    CountryID?: true
  }

  export type FinancialDetailsCountAggregateInputType = {
    ID?: true
    CreditCardType?: true
    CreditCardNumber?: true
    CreditCardExpiry?: true
    CreditCardCVV2?: true
    CountryID?: true
    _all?: true
  }

  export type FinancialDetailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FinancialDetails to aggregate.
     */
    where?: FinancialDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinancialDetails to fetch.
     */
    orderBy?: FinancialDetailsOrderByWithRelationInput | FinancialDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FinancialDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinancialDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinancialDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FinancialDetails
    **/
    _count?: true | FinancialDetailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FinancialDetailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FinancialDetailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FinancialDetailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FinancialDetailsMaxAggregateInputType
  }

  export type GetFinancialDetailsAggregateType<T extends FinancialDetailsAggregateArgs> = {
        [P in keyof T & keyof AggregateFinancialDetails]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFinancialDetails[P]>
      : GetScalarType<T[P], AggregateFinancialDetails[P]>
  }




  export type FinancialDetailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FinancialDetailsWhereInput
    orderBy?: FinancialDetailsOrderByWithAggregationInput | FinancialDetailsOrderByWithAggregationInput[]
    by: FinancialDetailsScalarFieldEnum[] | FinancialDetailsScalarFieldEnum
    having?: FinancialDetailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FinancialDetailsCountAggregateInputType | true
    _avg?: FinancialDetailsAvgAggregateInputType
    _sum?: FinancialDetailsSumAggregateInputType
    _min?: FinancialDetailsMinAggregateInputType
    _max?: FinancialDetailsMaxAggregateInputType
  }

  export type FinancialDetailsGroupByOutputType = {
    ID: number
    CreditCardType: string | null
    CreditCardNumber: string | null
    CreditCardExpiry: string | null
    CreditCardCVV2: number | null
    CountryID: number
    _count: FinancialDetailsCountAggregateOutputType | null
    _avg: FinancialDetailsAvgAggregateOutputType | null
    _sum: FinancialDetailsSumAggregateOutputType | null
    _min: FinancialDetailsMinAggregateOutputType | null
    _max: FinancialDetailsMaxAggregateOutputType | null
  }

  type GetFinancialDetailsGroupByPayload<T extends FinancialDetailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FinancialDetailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FinancialDetailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FinancialDetailsGroupByOutputType[P]>
            : GetScalarType<T[P], FinancialDetailsGroupByOutputType[P]>
        }
      >
    >


  export type FinancialDetailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    CreditCardType?: boolean
    CreditCardNumber?: boolean
    CreditCardExpiry?: boolean
    CreditCardCVV2?: boolean
    CountryID?: boolean
    Country?: boolean | CountriesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["financialDetails"]>


  export type FinancialDetailsSelectScalar = {
    ID?: boolean
    CreditCardType?: boolean
    CreditCardNumber?: boolean
    CreditCardExpiry?: boolean
    CreditCardCVV2?: boolean
    CountryID?: boolean
  }

  export type FinancialDetailsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Country?: boolean | CountriesDefaultArgs<ExtArgs>
  }

  export type $FinancialDetailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FinancialDetails"
    objects: {
      Country: Prisma.$CountriesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      ID: number
      CreditCardType: string | null
      CreditCardNumber: string | null
      CreditCardExpiry: string | null
      CreditCardCVV2: number | null
      CountryID: number
    }, ExtArgs["result"]["financialDetails"]>
    composites: {}
  }

  type FinancialDetailsGetPayload<S extends boolean | null | undefined | FinancialDetailsDefaultArgs> = $Result.GetResult<Prisma.$FinancialDetailsPayload, S>

  type FinancialDetailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FinancialDetailsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FinancialDetailsCountAggregateInputType | true
    }

  export interface FinancialDetailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FinancialDetails'], meta: { name: 'FinancialDetails' } }
    /**
     * Find zero or one FinancialDetails that matches the filter.
     * @param {FinancialDetailsFindUniqueArgs} args - Arguments to find a FinancialDetails
     * @example
     * // Get one FinancialDetails
     * const financialDetails = await prisma.financialDetails.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FinancialDetailsFindUniqueArgs>(args: SelectSubset<T, FinancialDetailsFindUniqueArgs<ExtArgs>>): Prisma__FinancialDetailsClient<$Result.GetResult<Prisma.$FinancialDetailsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one FinancialDetails that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FinancialDetailsFindUniqueOrThrowArgs} args - Arguments to find a FinancialDetails
     * @example
     * // Get one FinancialDetails
     * const financialDetails = await prisma.financialDetails.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FinancialDetailsFindUniqueOrThrowArgs>(args: SelectSubset<T, FinancialDetailsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FinancialDetailsClient<$Result.GetResult<Prisma.$FinancialDetailsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first FinancialDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialDetailsFindFirstArgs} args - Arguments to find a FinancialDetails
     * @example
     * // Get one FinancialDetails
     * const financialDetails = await prisma.financialDetails.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FinancialDetailsFindFirstArgs>(args?: SelectSubset<T, FinancialDetailsFindFirstArgs<ExtArgs>>): Prisma__FinancialDetailsClient<$Result.GetResult<Prisma.$FinancialDetailsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first FinancialDetails that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialDetailsFindFirstOrThrowArgs} args - Arguments to find a FinancialDetails
     * @example
     * // Get one FinancialDetails
     * const financialDetails = await prisma.financialDetails.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FinancialDetailsFindFirstOrThrowArgs>(args?: SelectSubset<T, FinancialDetailsFindFirstOrThrowArgs<ExtArgs>>): Prisma__FinancialDetailsClient<$Result.GetResult<Prisma.$FinancialDetailsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more FinancialDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialDetailsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FinancialDetails
     * const financialDetails = await prisma.financialDetails.findMany()
     * 
     * // Get first 10 FinancialDetails
     * const financialDetails = await prisma.financialDetails.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const financialDetailsWithIDOnly = await prisma.financialDetails.findMany({ select: { ID: true } })
     * 
     */
    findMany<T extends FinancialDetailsFindManyArgs>(args?: SelectSubset<T, FinancialDetailsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FinancialDetailsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a FinancialDetails.
     * @param {FinancialDetailsCreateArgs} args - Arguments to create a FinancialDetails.
     * @example
     * // Create one FinancialDetails
     * const FinancialDetails = await prisma.financialDetails.create({
     *   data: {
     *     // ... data to create a FinancialDetails
     *   }
     * })
     * 
     */
    create<T extends FinancialDetailsCreateArgs>(args: SelectSubset<T, FinancialDetailsCreateArgs<ExtArgs>>): Prisma__FinancialDetailsClient<$Result.GetResult<Prisma.$FinancialDetailsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many FinancialDetails.
     * @param {FinancialDetailsCreateManyArgs} args - Arguments to create many FinancialDetails.
     * @example
     * // Create many FinancialDetails
     * const financialDetails = await prisma.financialDetails.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FinancialDetailsCreateManyArgs>(args?: SelectSubset<T, FinancialDetailsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a FinancialDetails.
     * @param {FinancialDetailsDeleteArgs} args - Arguments to delete one FinancialDetails.
     * @example
     * // Delete one FinancialDetails
     * const FinancialDetails = await prisma.financialDetails.delete({
     *   where: {
     *     // ... filter to delete one FinancialDetails
     *   }
     * })
     * 
     */
    delete<T extends FinancialDetailsDeleteArgs>(args: SelectSubset<T, FinancialDetailsDeleteArgs<ExtArgs>>): Prisma__FinancialDetailsClient<$Result.GetResult<Prisma.$FinancialDetailsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one FinancialDetails.
     * @param {FinancialDetailsUpdateArgs} args - Arguments to update one FinancialDetails.
     * @example
     * // Update one FinancialDetails
     * const financialDetails = await prisma.financialDetails.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FinancialDetailsUpdateArgs>(args: SelectSubset<T, FinancialDetailsUpdateArgs<ExtArgs>>): Prisma__FinancialDetailsClient<$Result.GetResult<Prisma.$FinancialDetailsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more FinancialDetails.
     * @param {FinancialDetailsDeleteManyArgs} args - Arguments to filter FinancialDetails to delete.
     * @example
     * // Delete a few FinancialDetails
     * const { count } = await prisma.financialDetails.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FinancialDetailsDeleteManyArgs>(args?: SelectSubset<T, FinancialDetailsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FinancialDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialDetailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FinancialDetails
     * const financialDetails = await prisma.financialDetails.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FinancialDetailsUpdateManyArgs>(args: SelectSubset<T, FinancialDetailsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FinancialDetails.
     * @param {FinancialDetailsUpsertArgs} args - Arguments to update or create a FinancialDetails.
     * @example
     * // Update or create a FinancialDetails
     * const financialDetails = await prisma.financialDetails.upsert({
     *   create: {
     *     // ... data to create a FinancialDetails
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FinancialDetails we want to update
     *   }
     * })
     */
    upsert<T extends FinancialDetailsUpsertArgs>(args: SelectSubset<T, FinancialDetailsUpsertArgs<ExtArgs>>): Prisma__FinancialDetailsClient<$Result.GetResult<Prisma.$FinancialDetailsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of FinancialDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialDetailsCountArgs} args - Arguments to filter FinancialDetails to count.
     * @example
     * // Count the number of FinancialDetails
     * const count = await prisma.financialDetails.count({
     *   where: {
     *     // ... the filter for the FinancialDetails we want to count
     *   }
     * })
    **/
    count<T extends FinancialDetailsCountArgs>(
      args?: Subset<T, FinancialDetailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FinancialDetailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FinancialDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialDetailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FinancialDetailsAggregateArgs>(args: Subset<T, FinancialDetailsAggregateArgs>): Prisma.PrismaPromise<GetFinancialDetailsAggregateType<T>>

    /**
     * Group by FinancialDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FinancialDetailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FinancialDetailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FinancialDetailsGroupByArgs['orderBy'] }
        : { orderBy?: FinancialDetailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FinancialDetailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFinancialDetailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FinancialDetails model
   */
  readonly fields: FinancialDetailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FinancialDetails.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FinancialDetailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Country<T extends CountriesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CountriesDefaultArgs<ExtArgs>>): Prisma__CountriesClient<$Result.GetResult<Prisma.$CountriesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FinancialDetails model
   */ 
  interface FinancialDetailsFieldRefs {
    readonly ID: FieldRef<"FinancialDetails", 'Int'>
    readonly CreditCardType: FieldRef<"FinancialDetails", 'String'>
    readonly CreditCardNumber: FieldRef<"FinancialDetails", 'String'>
    readonly CreditCardExpiry: FieldRef<"FinancialDetails", 'String'>
    readonly CreditCardCVV2: FieldRef<"FinancialDetails", 'Int'>
    readonly CountryID: FieldRef<"FinancialDetails", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * FinancialDetails findUnique
   */
  export type FinancialDetailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialDetails
     */
    select?: FinancialDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialDetailsInclude<ExtArgs> | null
    /**
     * Filter, which FinancialDetails to fetch.
     */
    where: FinancialDetailsWhereUniqueInput
  }

  /**
   * FinancialDetails findUniqueOrThrow
   */
  export type FinancialDetailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialDetails
     */
    select?: FinancialDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialDetailsInclude<ExtArgs> | null
    /**
     * Filter, which FinancialDetails to fetch.
     */
    where: FinancialDetailsWhereUniqueInput
  }

  /**
   * FinancialDetails findFirst
   */
  export type FinancialDetailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialDetails
     */
    select?: FinancialDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialDetailsInclude<ExtArgs> | null
    /**
     * Filter, which FinancialDetails to fetch.
     */
    where?: FinancialDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinancialDetails to fetch.
     */
    orderBy?: FinancialDetailsOrderByWithRelationInput | FinancialDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FinancialDetails.
     */
    cursor?: FinancialDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinancialDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinancialDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FinancialDetails.
     */
    distinct?: FinancialDetailsScalarFieldEnum | FinancialDetailsScalarFieldEnum[]
  }

  /**
   * FinancialDetails findFirstOrThrow
   */
  export type FinancialDetailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialDetails
     */
    select?: FinancialDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialDetailsInclude<ExtArgs> | null
    /**
     * Filter, which FinancialDetails to fetch.
     */
    where?: FinancialDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinancialDetails to fetch.
     */
    orderBy?: FinancialDetailsOrderByWithRelationInput | FinancialDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FinancialDetails.
     */
    cursor?: FinancialDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinancialDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinancialDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FinancialDetails.
     */
    distinct?: FinancialDetailsScalarFieldEnum | FinancialDetailsScalarFieldEnum[]
  }

  /**
   * FinancialDetails findMany
   */
  export type FinancialDetailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialDetails
     */
    select?: FinancialDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialDetailsInclude<ExtArgs> | null
    /**
     * Filter, which FinancialDetails to fetch.
     */
    where?: FinancialDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FinancialDetails to fetch.
     */
    orderBy?: FinancialDetailsOrderByWithRelationInput | FinancialDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FinancialDetails.
     */
    cursor?: FinancialDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FinancialDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FinancialDetails.
     */
    skip?: number
    distinct?: FinancialDetailsScalarFieldEnum | FinancialDetailsScalarFieldEnum[]
  }

  /**
   * FinancialDetails create
   */
  export type FinancialDetailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialDetails
     */
    select?: FinancialDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialDetailsInclude<ExtArgs> | null
    /**
     * The data needed to create a FinancialDetails.
     */
    data: XOR<FinancialDetailsCreateInput, FinancialDetailsUncheckedCreateInput>
  }

  /**
   * FinancialDetails createMany
   */
  export type FinancialDetailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FinancialDetails.
     */
    data: FinancialDetailsCreateManyInput | FinancialDetailsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FinancialDetails update
   */
  export type FinancialDetailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialDetails
     */
    select?: FinancialDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialDetailsInclude<ExtArgs> | null
    /**
     * The data needed to update a FinancialDetails.
     */
    data: XOR<FinancialDetailsUpdateInput, FinancialDetailsUncheckedUpdateInput>
    /**
     * Choose, which FinancialDetails to update.
     */
    where: FinancialDetailsWhereUniqueInput
  }

  /**
   * FinancialDetails updateMany
   */
  export type FinancialDetailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FinancialDetails.
     */
    data: XOR<FinancialDetailsUpdateManyMutationInput, FinancialDetailsUncheckedUpdateManyInput>
    /**
     * Filter which FinancialDetails to update
     */
    where?: FinancialDetailsWhereInput
  }

  /**
   * FinancialDetails upsert
   */
  export type FinancialDetailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialDetails
     */
    select?: FinancialDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialDetailsInclude<ExtArgs> | null
    /**
     * The filter to search for the FinancialDetails to update in case it exists.
     */
    where: FinancialDetailsWhereUniqueInput
    /**
     * In case the FinancialDetails found by the `where` argument doesn't exist, create a new FinancialDetails with this data.
     */
    create: XOR<FinancialDetailsCreateInput, FinancialDetailsUncheckedCreateInput>
    /**
     * In case the FinancialDetails was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FinancialDetailsUpdateInput, FinancialDetailsUncheckedUpdateInput>
  }

  /**
   * FinancialDetails delete
   */
  export type FinancialDetailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialDetails
     */
    select?: FinancialDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialDetailsInclude<ExtArgs> | null
    /**
     * Filter which FinancialDetails to delete.
     */
    where: FinancialDetailsWhereUniqueInput
  }

  /**
   * FinancialDetails deleteMany
   */
  export type FinancialDetailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FinancialDetails to delete
     */
    where?: FinancialDetailsWhereInput
  }

  /**
   * FinancialDetails without action
   */
  export type FinancialDetailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FinancialDetails
     */
    select?: FinancialDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FinancialDetailsInclude<ExtArgs> | null
  }


  /**
   * Model InternetDetails
   */

  export type AggregateInternetDetails = {
    _count: InternetDetailsCountAggregateOutputType | null
    _avg: InternetDetailsAvgAggregateOutputType | null
    _sum: InternetDetailsSumAggregateOutputType | null
    _min: InternetDetailsMinAggregateOutputType | null
    _max: InternetDetailsMaxAggregateOutputType | null
  }

  export type InternetDetailsAvgAggregateOutputType = {
    ID: number | null
    CountryID: number | null
  }

  export type InternetDetailsSumAggregateOutputType = {
    ID: number | null
    CountryID: number | null
  }

  export type InternetDetailsMinAggregateOutputType = {
    ID: number | null
    UserName: string | null
    Password: string | null
    IPv4Address: string | null
    IPv6Address: string | null
    UserAgent: string | null
    CountryID: number | null
  }

  export type InternetDetailsMaxAggregateOutputType = {
    ID: number | null
    UserName: string | null
    Password: string | null
    IPv4Address: string | null
    IPv6Address: string | null
    UserAgent: string | null
    CountryID: number | null
  }

  export type InternetDetailsCountAggregateOutputType = {
    ID: number
    UserName: number
    Password: number
    IPv4Address: number
    IPv6Address: number
    UserAgent: number
    CountryID: number
    _all: number
  }


  export type InternetDetailsAvgAggregateInputType = {
    ID?: true
    CountryID?: true
  }

  export type InternetDetailsSumAggregateInputType = {
    ID?: true
    CountryID?: true
  }

  export type InternetDetailsMinAggregateInputType = {
    ID?: true
    UserName?: true
    Password?: true
    IPv4Address?: true
    IPv6Address?: true
    UserAgent?: true
    CountryID?: true
  }

  export type InternetDetailsMaxAggregateInputType = {
    ID?: true
    UserName?: true
    Password?: true
    IPv4Address?: true
    IPv6Address?: true
    UserAgent?: true
    CountryID?: true
  }

  export type InternetDetailsCountAggregateInputType = {
    ID?: true
    UserName?: true
    Password?: true
    IPv4Address?: true
    IPv6Address?: true
    UserAgent?: true
    CountryID?: true
    _all?: true
  }

  export type InternetDetailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InternetDetails to aggregate.
     */
    where?: InternetDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InternetDetails to fetch.
     */
    orderBy?: InternetDetailsOrderByWithRelationInput | InternetDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InternetDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InternetDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InternetDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InternetDetails
    **/
    _count?: true | InternetDetailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InternetDetailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InternetDetailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InternetDetailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InternetDetailsMaxAggregateInputType
  }

  export type GetInternetDetailsAggregateType<T extends InternetDetailsAggregateArgs> = {
        [P in keyof T & keyof AggregateInternetDetails]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInternetDetails[P]>
      : GetScalarType<T[P], AggregateInternetDetails[P]>
  }




  export type InternetDetailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InternetDetailsWhereInput
    orderBy?: InternetDetailsOrderByWithAggregationInput | InternetDetailsOrderByWithAggregationInput[]
    by: InternetDetailsScalarFieldEnum[] | InternetDetailsScalarFieldEnum
    having?: InternetDetailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InternetDetailsCountAggregateInputType | true
    _avg?: InternetDetailsAvgAggregateInputType
    _sum?: InternetDetailsSumAggregateInputType
    _min?: InternetDetailsMinAggregateInputType
    _max?: InternetDetailsMaxAggregateInputType
  }

  export type InternetDetailsGroupByOutputType = {
    ID: number
    UserName: string | null
    Password: string | null
    IPv4Address: string | null
    IPv6Address: string | null
    UserAgent: string | null
    CountryID: number
    _count: InternetDetailsCountAggregateOutputType | null
    _avg: InternetDetailsAvgAggregateOutputType | null
    _sum: InternetDetailsSumAggregateOutputType | null
    _min: InternetDetailsMinAggregateOutputType | null
    _max: InternetDetailsMaxAggregateOutputType | null
  }

  type GetInternetDetailsGroupByPayload<T extends InternetDetailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InternetDetailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InternetDetailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InternetDetailsGroupByOutputType[P]>
            : GetScalarType<T[P], InternetDetailsGroupByOutputType[P]>
        }
      >
    >


  export type InternetDetailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    UserName?: boolean
    Password?: boolean
    IPv4Address?: boolean
    IPv6Address?: boolean
    UserAgent?: boolean
    CountryID?: boolean
    Country?: boolean | CountriesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["internetDetails"]>


  export type InternetDetailsSelectScalar = {
    ID?: boolean
    UserName?: boolean
    Password?: boolean
    IPv4Address?: boolean
    IPv6Address?: boolean
    UserAgent?: boolean
    CountryID?: boolean
  }

  export type InternetDetailsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Country?: boolean | CountriesDefaultArgs<ExtArgs>
  }

  export type $InternetDetailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InternetDetails"
    objects: {
      Country: Prisma.$CountriesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      ID: number
      UserName: string | null
      Password: string | null
      IPv4Address: string | null
      IPv6Address: string | null
      UserAgent: string | null
      CountryID: number
    }, ExtArgs["result"]["internetDetails"]>
    composites: {}
  }

  type InternetDetailsGetPayload<S extends boolean | null | undefined | InternetDetailsDefaultArgs> = $Result.GetResult<Prisma.$InternetDetailsPayload, S>

  type InternetDetailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InternetDetailsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InternetDetailsCountAggregateInputType | true
    }

  export interface InternetDetailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InternetDetails'], meta: { name: 'InternetDetails' } }
    /**
     * Find zero or one InternetDetails that matches the filter.
     * @param {InternetDetailsFindUniqueArgs} args - Arguments to find a InternetDetails
     * @example
     * // Get one InternetDetails
     * const internetDetails = await prisma.internetDetails.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InternetDetailsFindUniqueArgs>(args: SelectSubset<T, InternetDetailsFindUniqueArgs<ExtArgs>>): Prisma__InternetDetailsClient<$Result.GetResult<Prisma.$InternetDetailsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one InternetDetails that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InternetDetailsFindUniqueOrThrowArgs} args - Arguments to find a InternetDetails
     * @example
     * // Get one InternetDetails
     * const internetDetails = await prisma.internetDetails.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InternetDetailsFindUniqueOrThrowArgs>(args: SelectSubset<T, InternetDetailsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InternetDetailsClient<$Result.GetResult<Prisma.$InternetDetailsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first InternetDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InternetDetailsFindFirstArgs} args - Arguments to find a InternetDetails
     * @example
     * // Get one InternetDetails
     * const internetDetails = await prisma.internetDetails.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InternetDetailsFindFirstArgs>(args?: SelectSubset<T, InternetDetailsFindFirstArgs<ExtArgs>>): Prisma__InternetDetailsClient<$Result.GetResult<Prisma.$InternetDetailsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first InternetDetails that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InternetDetailsFindFirstOrThrowArgs} args - Arguments to find a InternetDetails
     * @example
     * // Get one InternetDetails
     * const internetDetails = await prisma.internetDetails.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InternetDetailsFindFirstOrThrowArgs>(args?: SelectSubset<T, InternetDetailsFindFirstOrThrowArgs<ExtArgs>>): Prisma__InternetDetailsClient<$Result.GetResult<Prisma.$InternetDetailsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more InternetDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InternetDetailsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InternetDetails
     * const internetDetails = await prisma.internetDetails.findMany()
     * 
     * // Get first 10 InternetDetails
     * const internetDetails = await prisma.internetDetails.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const internetDetailsWithIDOnly = await prisma.internetDetails.findMany({ select: { ID: true } })
     * 
     */
    findMany<T extends InternetDetailsFindManyArgs>(args?: SelectSubset<T, InternetDetailsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InternetDetailsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a InternetDetails.
     * @param {InternetDetailsCreateArgs} args - Arguments to create a InternetDetails.
     * @example
     * // Create one InternetDetails
     * const InternetDetails = await prisma.internetDetails.create({
     *   data: {
     *     // ... data to create a InternetDetails
     *   }
     * })
     * 
     */
    create<T extends InternetDetailsCreateArgs>(args: SelectSubset<T, InternetDetailsCreateArgs<ExtArgs>>): Prisma__InternetDetailsClient<$Result.GetResult<Prisma.$InternetDetailsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many InternetDetails.
     * @param {InternetDetailsCreateManyArgs} args - Arguments to create many InternetDetails.
     * @example
     * // Create many InternetDetails
     * const internetDetails = await prisma.internetDetails.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InternetDetailsCreateManyArgs>(args?: SelectSubset<T, InternetDetailsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a InternetDetails.
     * @param {InternetDetailsDeleteArgs} args - Arguments to delete one InternetDetails.
     * @example
     * // Delete one InternetDetails
     * const InternetDetails = await prisma.internetDetails.delete({
     *   where: {
     *     // ... filter to delete one InternetDetails
     *   }
     * })
     * 
     */
    delete<T extends InternetDetailsDeleteArgs>(args: SelectSubset<T, InternetDetailsDeleteArgs<ExtArgs>>): Prisma__InternetDetailsClient<$Result.GetResult<Prisma.$InternetDetailsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one InternetDetails.
     * @param {InternetDetailsUpdateArgs} args - Arguments to update one InternetDetails.
     * @example
     * // Update one InternetDetails
     * const internetDetails = await prisma.internetDetails.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InternetDetailsUpdateArgs>(args: SelectSubset<T, InternetDetailsUpdateArgs<ExtArgs>>): Prisma__InternetDetailsClient<$Result.GetResult<Prisma.$InternetDetailsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more InternetDetails.
     * @param {InternetDetailsDeleteManyArgs} args - Arguments to filter InternetDetails to delete.
     * @example
     * // Delete a few InternetDetails
     * const { count } = await prisma.internetDetails.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InternetDetailsDeleteManyArgs>(args?: SelectSubset<T, InternetDetailsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InternetDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InternetDetailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InternetDetails
     * const internetDetails = await prisma.internetDetails.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InternetDetailsUpdateManyArgs>(args: SelectSubset<T, InternetDetailsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InternetDetails.
     * @param {InternetDetailsUpsertArgs} args - Arguments to update or create a InternetDetails.
     * @example
     * // Update or create a InternetDetails
     * const internetDetails = await prisma.internetDetails.upsert({
     *   create: {
     *     // ... data to create a InternetDetails
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InternetDetails we want to update
     *   }
     * })
     */
    upsert<T extends InternetDetailsUpsertArgs>(args: SelectSubset<T, InternetDetailsUpsertArgs<ExtArgs>>): Prisma__InternetDetailsClient<$Result.GetResult<Prisma.$InternetDetailsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of InternetDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InternetDetailsCountArgs} args - Arguments to filter InternetDetails to count.
     * @example
     * // Count the number of InternetDetails
     * const count = await prisma.internetDetails.count({
     *   where: {
     *     // ... the filter for the InternetDetails we want to count
     *   }
     * })
    **/
    count<T extends InternetDetailsCountArgs>(
      args?: Subset<T, InternetDetailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InternetDetailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InternetDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InternetDetailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InternetDetailsAggregateArgs>(args: Subset<T, InternetDetailsAggregateArgs>): Prisma.PrismaPromise<GetInternetDetailsAggregateType<T>>

    /**
     * Group by InternetDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InternetDetailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InternetDetailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InternetDetailsGroupByArgs['orderBy'] }
        : { orderBy?: InternetDetailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InternetDetailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInternetDetailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InternetDetails model
   */
  readonly fields: InternetDetailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InternetDetails.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InternetDetailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Country<T extends CountriesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CountriesDefaultArgs<ExtArgs>>): Prisma__CountriesClient<$Result.GetResult<Prisma.$CountriesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InternetDetails model
   */ 
  interface InternetDetailsFieldRefs {
    readonly ID: FieldRef<"InternetDetails", 'Int'>
    readonly UserName: FieldRef<"InternetDetails", 'String'>
    readonly Password: FieldRef<"InternetDetails", 'String'>
    readonly IPv4Address: FieldRef<"InternetDetails", 'String'>
    readonly IPv6Address: FieldRef<"InternetDetails", 'String'>
    readonly UserAgent: FieldRef<"InternetDetails", 'String'>
    readonly CountryID: FieldRef<"InternetDetails", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * InternetDetails findUnique
   */
  export type InternetDetailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InternetDetails
     */
    select?: InternetDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InternetDetailsInclude<ExtArgs> | null
    /**
     * Filter, which InternetDetails to fetch.
     */
    where: InternetDetailsWhereUniqueInput
  }

  /**
   * InternetDetails findUniqueOrThrow
   */
  export type InternetDetailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InternetDetails
     */
    select?: InternetDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InternetDetailsInclude<ExtArgs> | null
    /**
     * Filter, which InternetDetails to fetch.
     */
    where: InternetDetailsWhereUniqueInput
  }

  /**
   * InternetDetails findFirst
   */
  export type InternetDetailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InternetDetails
     */
    select?: InternetDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InternetDetailsInclude<ExtArgs> | null
    /**
     * Filter, which InternetDetails to fetch.
     */
    where?: InternetDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InternetDetails to fetch.
     */
    orderBy?: InternetDetailsOrderByWithRelationInput | InternetDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InternetDetails.
     */
    cursor?: InternetDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InternetDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InternetDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InternetDetails.
     */
    distinct?: InternetDetailsScalarFieldEnum | InternetDetailsScalarFieldEnum[]
  }

  /**
   * InternetDetails findFirstOrThrow
   */
  export type InternetDetailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InternetDetails
     */
    select?: InternetDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InternetDetailsInclude<ExtArgs> | null
    /**
     * Filter, which InternetDetails to fetch.
     */
    where?: InternetDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InternetDetails to fetch.
     */
    orderBy?: InternetDetailsOrderByWithRelationInput | InternetDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InternetDetails.
     */
    cursor?: InternetDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InternetDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InternetDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InternetDetails.
     */
    distinct?: InternetDetailsScalarFieldEnum | InternetDetailsScalarFieldEnum[]
  }

  /**
   * InternetDetails findMany
   */
  export type InternetDetailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InternetDetails
     */
    select?: InternetDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InternetDetailsInclude<ExtArgs> | null
    /**
     * Filter, which InternetDetails to fetch.
     */
    where?: InternetDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InternetDetails to fetch.
     */
    orderBy?: InternetDetailsOrderByWithRelationInput | InternetDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InternetDetails.
     */
    cursor?: InternetDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InternetDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InternetDetails.
     */
    skip?: number
    distinct?: InternetDetailsScalarFieldEnum | InternetDetailsScalarFieldEnum[]
  }

  /**
   * InternetDetails create
   */
  export type InternetDetailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InternetDetails
     */
    select?: InternetDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InternetDetailsInclude<ExtArgs> | null
    /**
     * The data needed to create a InternetDetails.
     */
    data: XOR<InternetDetailsCreateInput, InternetDetailsUncheckedCreateInput>
  }

  /**
   * InternetDetails createMany
   */
  export type InternetDetailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InternetDetails.
     */
    data: InternetDetailsCreateManyInput | InternetDetailsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InternetDetails update
   */
  export type InternetDetailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InternetDetails
     */
    select?: InternetDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InternetDetailsInclude<ExtArgs> | null
    /**
     * The data needed to update a InternetDetails.
     */
    data: XOR<InternetDetailsUpdateInput, InternetDetailsUncheckedUpdateInput>
    /**
     * Choose, which InternetDetails to update.
     */
    where: InternetDetailsWhereUniqueInput
  }

  /**
   * InternetDetails updateMany
   */
  export type InternetDetailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InternetDetails.
     */
    data: XOR<InternetDetailsUpdateManyMutationInput, InternetDetailsUncheckedUpdateManyInput>
    /**
     * Filter which InternetDetails to update
     */
    where?: InternetDetailsWhereInput
  }

  /**
   * InternetDetails upsert
   */
  export type InternetDetailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InternetDetails
     */
    select?: InternetDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InternetDetailsInclude<ExtArgs> | null
    /**
     * The filter to search for the InternetDetails to update in case it exists.
     */
    where: InternetDetailsWhereUniqueInput
    /**
     * In case the InternetDetails found by the `where` argument doesn't exist, create a new InternetDetails with this data.
     */
    create: XOR<InternetDetailsCreateInput, InternetDetailsUncheckedCreateInput>
    /**
     * In case the InternetDetails was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InternetDetailsUpdateInput, InternetDetailsUncheckedUpdateInput>
  }

  /**
   * InternetDetails delete
   */
  export type InternetDetailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InternetDetails
     */
    select?: InternetDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InternetDetailsInclude<ExtArgs> | null
    /**
     * Filter which InternetDetails to delete.
     */
    where: InternetDetailsWhereUniqueInput
  }

  /**
   * InternetDetails deleteMany
   */
  export type InternetDetailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InternetDetails to delete
     */
    where?: InternetDetailsWhereInput
  }

  /**
   * InternetDetails without action
   */
  export type InternetDetailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InternetDetails
     */
    select?: InternetDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InternetDetailsInclude<ExtArgs> | null
  }


  /**
   * Model EducationDetails
   */

  export type AggregateEducationDetails = {
    _count: EducationDetailsCountAggregateOutputType | null
    _avg: EducationDetailsAvgAggregateOutputType | null
    _sum: EducationDetailsSumAggregateOutputType | null
    _min: EducationDetailsMinAggregateOutputType | null
    _max: EducationDetailsMaxAggregateOutputType | null
  }

  export type EducationDetailsAvgAggregateOutputType = {
    ID: number | null
    CountryID: number | null
  }

  export type EducationDetailsSumAggregateOutputType = {
    ID: number | null
    CountryID: number | null
  }

  export type EducationDetailsMinAggregateOutputType = {
    ID: number | null
    Qualification: string | null
    Institution: string | null
    CountryID: number | null
  }

  export type EducationDetailsMaxAggregateOutputType = {
    ID: number | null
    Qualification: string | null
    Institution: string | null
    CountryID: number | null
  }

  export type EducationDetailsCountAggregateOutputType = {
    ID: number
    Qualification: number
    Institution: number
    CountryID: number
    _all: number
  }


  export type EducationDetailsAvgAggregateInputType = {
    ID?: true
    CountryID?: true
  }

  export type EducationDetailsSumAggregateInputType = {
    ID?: true
    CountryID?: true
  }

  export type EducationDetailsMinAggregateInputType = {
    ID?: true
    Qualification?: true
    Institution?: true
    CountryID?: true
  }

  export type EducationDetailsMaxAggregateInputType = {
    ID?: true
    Qualification?: true
    Institution?: true
    CountryID?: true
  }

  export type EducationDetailsCountAggregateInputType = {
    ID?: true
    Qualification?: true
    Institution?: true
    CountryID?: true
    _all?: true
  }

  export type EducationDetailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EducationDetails to aggregate.
     */
    where?: EducationDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EducationDetails to fetch.
     */
    orderBy?: EducationDetailsOrderByWithRelationInput | EducationDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EducationDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EducationDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EducationDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EducationDetails
    **/
    _count?: true | EducationDetailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EducationDetailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EducationDetailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EducationDetailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EducationDetailsMaxAggregateInputType
  }

  export type GetEducationDetailsAggregateType<T extends EducationDetailsAggregateArgs> = {
        [P in keyof T & keyof AggregateEducationDetails]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEducationDetails[P]>
      : GetScalarType<T[P], AggregateEducationDetails[P]>
  }




  export type EducationDetailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EducationDetailsWhereInput
    orderBy?: EducationDetailsOrderByWithAggregationInput | EducationDetailsOrderByWithAggregationInput[]
    by: EducationDetailsScalarFieldEnum[] | EducationDetailsScalarFieldEnum
    having?: EducationDetailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EducationDetailsCountAggregateInputType | true
    _avg?: EducationDetailsAvgAggregateInputType
    _sum?: EducationDetailsSumAggregateInputType
    _min?: EducationDetailsMinAggregateInputType
    _max?: EducationDetailsMaxAggregateInputType
  }

  export type EducationDetailsGroupByOutputType = {
    ID: number
    Qualification: string | null
    Institution: string | null
    CountryID: number
    _count: EducationDetailsCountAggregateOutputType | null
    _avg: EducationDetailsAvgAggregateOutputType | null
    _sum: EducationDetailsSumAggregateOutputType | null
    _min: EducationDetailsMinAggregateOutputType | null
    _max: EducationDetailsMaxAggregateOutputType | null
  }

  type GetEducationDetailsGroupByPayload<T extends EducationDetailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EducationDetailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EducationDetailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EducationDetailsGroupByOutputType[P]>
            : GetScalarType<T[P], EducationDetailsGroupByOutputType[P]>
        }
      >
    >


  export type EducationDetailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    Qualification?: boolean
    Institution?: boolean
    CountryID?: boolean
    Country?: boolean | CountriesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["educationDetails"]>


  export type EducationDetailsSelectScalar = {
    ID?: boolean
    Qualification?: boolean
    Institution?: boolean
    CountryID?: boolean
  }

  export type EducationDetailsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Country?: boolean | CountriesDefaultArgs<ExtArgs>
  }

  export type $EducationDetailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EducationDetails"
    objects: {
      Country: Prisma.$CountriesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      ID: number
      Qualification: string | null
      Institution: string | null
      CountryID: number
    }, ExtArgs["result"]["educationDetails"]>
    composites: {}
  }

  type EducationDetailsGetPayload<S extends boolean | null | undefined | EducationDetailsDefaultArgs> = $Result.GetResult<Prisma.$EducationDetailsPayload, S>

  type EducationDetailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EducationDetailsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EducationDetailsCountAggregateInputType | true
    }

  export interface EducationDetailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EducationDetails'], meta: { name: 'EducationDetails' } }
    /**
     * Find zero or one EducationDetails that matches the filter.
     * @param {EducationDetailsFindUniqueArgs} args - Arguments to find a EducationDetails
     * @example
     * // Get one EducationDetails
     * const educationDetails = await prisma.educationDetails.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EducationDetailsFindUniqueArgs>(args: SelectSubset<T, EducationDetailsFindUniqueArgs<ExtArgs>>): Prisma__EducationDetailsClient<$Result.GetResult<Prisma.$EducationDetailsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EducationDetails that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EducationDetailsFindUniqueOrThrowArgs} args - Arguments to find a EducationDetails
     * @example
     * // Get one EducationDetails
     * const educationDetails = await prisma.educationDetails.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EducationDetailsFindUniqueOrThrowArgs>(args: SelectSubset<T, EducationDetailsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EducationDetailsClient<$Result.GetResult<Prisma.$EducationDetailsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EducationDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationDetailsFindFirstArgs} args - Arguments to find a EducationDetails
     * @example
     * // Get one EducationDetails
     * const educationDetails = await prisma.educationDetails.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EducationDetailsFindFirstArgs>(args?: SelectSubset<T, EducationDetailsFindFirstArgs<ExtArgs>>): Prisma__EducationDetailsClient<$Result.GetResult<Prisma.$EducationDetailsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EducationDetails that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationDetailsFindFirstOrThrowArgs} args - Arguments to find a EducationDetails
     * @example
     * // Get one EducationDetails
     * const educationDetails = await prisma.educationDetails.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EducationDetailsFindFirstOrThrowArgs>(args?: SelectSubset<T, EducationDetailsFindFirstOrThrowArgs<ExtArgs>>): Prisma__EducationDetailsClient<$Result.GetResult<Prisma.$EducationDetailsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EducationDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationDetailsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EducationDetails
     * const educationDetails = await prisma.educationDetails.findMany()
     * 
     * // Get first 10 EducationDetails
     * const educationDetails = await prisma.educationDetails.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const educationDetailsWithIDOnly = await prisma.educationDetails.findMany({ select: { ID: true } })
     * 
     */
    findMany<T extends EducationDetailsFindManyArgs>(args?: SelectSubset<T, EducationDetailsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EducationDetailsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EducationDetails.
     * @param {EducationDetailsCreateArgs} args - Arguments to create a EducationDetails.
     * @example
     * // Create one EducationDetails
     * const EducationDetails = await prisma.educationDetails.create({
     *   data: {
     *     // ... data to create a EducationDetails
     *   }
     * })
     * 
     */
    create<T extends EducationDetailsCreateArgs>(args: SelectSubset<T, EducationDetailsCreateArgs<ExtArgs>>): Prisma__EducationDetailsClient<$Result.GetResult<Prisma.$EducationDetailsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EducationDetails.
     * @param {EducationDetailsCreateManyArgs} args - Arguments to create many EducationDetails.
     * @example
     * // Create many EducationDetails
     * const educationDetails = await prisma.educationDetails.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EducationDetailsCreateManyArgs>(args?: SelectSubset<T, EducationDetailsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EducationDetails.
     * @param {EducationDetailsDeleteArgs} args - Arguments to delete one EducationDetails.
     * @example
     * // Delete one EducationDetails
     * const EducationDetails = await prisma.educationDetails.delete({
     *   where: {
     *     // ... filter to delete one EducationDetails
     *   }
     * })
     * 
     */
    delete<T extends EducationDetailsDeleteArgs>(args: SelectSubset<T, EducationDetailsDeleteArgs<ExtArgs>>): Prisma__EducationDetailsClient<$Result.GetResult<Prisma.$EducationDetailsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EducationDetails.
     * @param {EducationDetailsUpdateArgs} args - Arguments to update one EducationDetails.
     * @example
     * // Update one EducationDetails
     * const educationDetails = await prisma.educationDetails.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EducationDetailsUpdateArgs>(args: SelectSubset<T, EducationDetailsUpdateArgs<ExtArgs>>): Prisma__EducationDetailsClient<$Result.GetResult<Prisma.$EducationDetailsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EducationDetails.
     * @param {EducationDetailsDeleteManyArgs} args - Arguments to filter EducationDetails to delete.
     * @example
     * // Delete a few EducationDetails
     * const { count } = await prisma.educationDetails.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EducationDetailsDeleteManyArgs>(args?: SelectSubset<T, EducationDetailsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EducationDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationDetailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EducationDetails
     * const educationDetails = await prisma.educationDetails.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EducationDetailsUpdateManyArgs>(args: SelectSubset<T, EducationDetailsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EducationDetails.
     * @param {EducationDetailsUpsertArgs} args - Arguments to update or create a EducationDetails.
     * @example
     * // Update or create a EducationDetails
     * const educationDetails = await prisma.educationDetails.upsert({
     *   create: {
     *     // ... data to create a EducationDetails
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EducationDetails we want to update
     *   }
     * })
     */
    upsert<T extends EducationDetailsUpsertArgs>(args: SelectSubset<T, EducationDetailsUpsertArgs<ExtArgs>>): Prisma__EducationDetailsClient<$Result.GetResult<Prisma.$EducationDetailsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EducationDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationDetailsCountArgs} args - Arguments to filter EducationDetails to count.
     * @example
     * // Count the number of EducationDetails
     * const count = await prisma.educationDetails.count({
     *   where: {
     *     // ... the filter for the EducationDetails we want to count
     *   }
     * })
    **/
    count<T extends EducationDetailsCountArgs>(
      args?: Subset<T, EducationDetailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EducationDetailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EducationDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationDetailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EducationDetailsAggregateArgs>(args: Subset<T, EducationDetailsAggregateArgs>): Prisma.PrismaPromise<GetEducationDetailsAggregateType<T>>

    /**
     * Group by EducationDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EducationDetailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EducationDetailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EducationDetailsGroupByArgs['orderBy'] }
        : { orderBy?: EducationDetailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EducationDetailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEducationDetailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EducationDetails model
   */
  readonly fields: EducationDetailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EducationDetails.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EducationDetailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Country<T extends CountriesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CountriesDefaultArgs<ExtArgs>>): Prisma__CountriesClient<$Result.GetResult<Prisma.$CountriesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EducationDetails model
   */ 
  interface EducationDetailsFieldRefs {
    readonly ID: FieldRef<"EducationDetails", 'Int'>
    readonly Qualification: FieldRef<"EducationDetails", 'String'>
    readonly Institution: FieldRef<"EducationDetails", 'String'>
    readonly CountryID: FieldRef<"EducationDetails", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * EducationDetails findUnique
   */
  export type EducationDetailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationDetails
     */
    select?: EducationDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationDetailsInclude<ExtArgs> | null
    /**
     * Filter, which EducationDetails to fetch.
     */
    where: EducationDetailsWhereUniqueInput
  }

  /**
   * EducationDetails findUniqueOrThrow
   */
  export type EducationDetailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationDetails
     */
    select?: EducationDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationDetailsInclude<ExtArgs> | null
    /**
     * Filter, which EducationDetails to fetch.
     */
    where: EducationDetailsWhereUniqueInput
  }

  /**
   * EducationDetails findFirst
   */
  export type EducationDetailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationDetails
     */
    select?: EducationDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationDetailsInclude<ExtArgs> | null
    /**
     * Filter, which EducationDetails to fetch.
     */
    where?: EducationDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EducationDetails to fetch.
     */
    orderBy?: EducationDetailsOrderByWithRelationInput | EducationDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EducationDetails.
     */
    cursor?: EducationDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EducationDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EducationDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EducationDetails.
     */
    distinct?: EducationDetailsScalarFieldEnum | EducationDetailsScalarFieldEnum[]
  }

  /**
   * EducationDetails findFirstOrThrow
   */
  export type EducationDetailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationDetails
     */
    select?: EducationDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationDetailsInclude<ExtArgs> | null
    /**
     * Filter, which EducationDetails to fetch.
     */
    where?: EducationDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EducationDetails to fetch.
     */
    orderBy?: EducationDetailsOrderByWithRelationInput | EducationDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EducationDetails.
     */
    cursor?: EducationDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EducationDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EducationDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EducationDetails.
     */
    distinct?: EducationDetailsScalarFieldEnum | EducationDetailsScalarFieldEnum[]
  }

  /**
   * EducationDetails findMany
   */
  export type EducationDetailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationDetails
     */
    select?: EducationDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationDetailsInclude<ExtArgs> | null
    /**
     * Filter, which EducationDetails to fetch.
     */
    where?: EducationDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EducationDetails to fetch.
     */
    orderBy?: EducationDetailsOrderByWithRelationInput | EducationDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EducationDetails.
     */
    cursor?: EducationDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EducationDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EducationDetails.
     */
    skip?: number
    distinct?: EducationDetailsScalarFieldEnum | EducationDetailsScalarFieldEnum[]
  }

  /**
   * EducationDetails create
   */
  export type EducationDetailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationDetails
     */
    select?: EducationDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationDetailsInclude<ExtArgs> | null
    /**
     * The data needed to create a EducationDetails.
     */
    data: XOR<EducationDetailsCreateInput, EducationDetailsUncheckedCreateInput>
  }

  /**
   * EducationDetails createMany
   */
  export type EducationDetailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EducationDetails.
     */
    data: EducationDetailsCreateManyInput | EducationDetailsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EducationDetails update
   */
  export type EducationDetailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationDetails
     */
    select?: EducationDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationDetailsInclude<ExtArgs> | null
    /**
     * The data needed to update a EducationDetails.
     */
    data: XOR<EducationDetailsUpdateInput, EducationDetailsUncheckedUpdateInput>
    /**
     * Choose, which EducationDetails to update.
     */
    where: EducationDetailsWhereUniqueInput
  }

  /**
   * EducationDetails updateMany
   */
  export type EducationDetailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EducationDetails.
     */
    data: XOR<EducationDetailsUpdateManyMutationInput, EducationDetailsUncheckedUpdateManyInput>
    /**
     * Filter which EducationDetails to update
     */
    where?: EducationDetailsWhereInput
  }

  /**
   * EducationDetails upsert
   */
  export type EducationDetailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationDetails
     */
    select?: EducationDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationDetailsInclude<ExtArgs> | null
    /**
     * The filter to search for the EducationDetails to update in case it exists.
     */
    where: EducationDetailsWhereUniqueInput
    /**
     * In case the EducationDetails found by the `where` argument doesn't exist, create a new EducationDetails with this data.
     */
    create: XOR<EducationDetailsCreateInput, EducationDetailsUncheckedCreateInput>
    /**
     * In case the EducationDetails was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EducationDetailsUpdateInput, EducationDetailsUncheckedUpdateInput>
  }

  /**
   * EducationDetails delete
   */
  export type EducationDetailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationDetails
     */
    select?: EducationDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationDetailsInclude<ExtArgs> | null
    /**
     * Filter which EducationDetails to delete.
     */
    where: EducationDetailsWhereUniqueInput
  }

  /**
   * EducationDetails deleteMany
   */
  export type EducationDetailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EducationDetails to delete
     */
    where?: EducationDetailsWhereInput
  }

  /**
   * EducationDetails without action
   */
  export type EducationDetailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EducationDetails
     */
    select?: EducationDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EducationDetailsInclude<ExtArgs> | null
  }


  /**
   * Model EmploymentDetails
   */

  export type AggregateEmploymentDetails = {
    _count: EmploymentDetailsCountAggregateOutputType | null
    _avg: EmploymentDetailsAvgAggregateOutputType | null
    _sum: EmploymentDetailsSumAggregateOutputType | null
    _min: EmploymentDetailsMinAggregateOutputType | null
    _max: EmploymentDetailsMaxAggregateOutputType | null
  }

  export type EmploymentDetailsAvgAggregateOutputType = {
    ID: number | null
    CountryID: number | null
  }

  export type EmploymentDetailsSumAggregateOutputType = {
    ID: number | null
    CountryID: number | null
  }

  export type EmploymentDetailsMinAggregateOutputType = {
    ID: number | null
    CompanyName: string | null
    Salary: string | null
    CompanyAddress: string | null
    JobTitle: string | null
    CompanyPhone: string | null
    CompanyEmail: string | null
    CountryID: number | null
  }

  export type EmploymentDetailsMaxAggregateOutputType = {
    ID: number | null
    CompanyName: string | null
    Salary: string | null
    CompanyAddress: string | null
    JobTitle: string | null
    CompanyPhone: string | null
    CompanyEmail: string | null
    CountryID: number | null
  }

  export type EmploymentDetailsCountAggregateOutputType = {
    ID: number
    CompanyName: number
    Salary: number
    CompanyAddress: number
    JobTitle: number
    CompanyPhone: number
    CompanyEmail: number
    CountryID: number
    _all: number
  }


  export type EmploymentDetailsAvgAggregateInputType = {
    ID?: true
    CountryID?: true
  }

  export type EmploymentDetailsSumAggregateInputType = {
    ID?: true
    CountryID?: true
  }

  export type EmploymentDetailsMinAggregateInputType = {
    ID?: true
    CompanyName?: true
    Salary?: true
    CompanyAddress?: true
    JobTitle?: true
    CompanyPhone?: true
    CompanyEmail?: true
    CountryID?: true
  }

  export type EmploymentDetailsMaxAggregateInputType = {
    ID?: true
    CompanyName?: true
    Salary?: true
    CompanyAddress?: true
    JobTitle?: true
    CompanyPhone?: true
    CompanyEmail?: true
    CountryID?: true
  }

  export type EmploymentDetailsCountAggregateInputType = {
    ID?: true
    CompanyName?: true
    Salary?: true
    CompanyAddress?: true
    JobTitle?: true
    CompanyPhone?: true
    CompanyEmail?: true
    CountryID?: true
    _all?: true
  }

  export type EmploymentDetailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmploymentDetails to aggregate.
     */
    where?: EmploymentDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmploymentDetails to fetch.
     */
    orderBy?: EmploymentDetailsOrderByWithRelationInput | EmploymentDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmploymentDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmploymentDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmploymentDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmploymentDetails
    **/
    _count?: true | EmploymentDetailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmploymentDetailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmploymentDetailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmploymentDetailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmploymentDetailsMaxAggregateInputType
  }

  export type GetEmploymentDetailsAggregateType<T extends EmploymentDetailsAggregateArgs> = {
        [P in keyof T & keyof AggregateEmploymentDetails]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmploymentDetails[P]>
      : GetScalarType<T[P], AggregateEmploymentDetails[P]>
  }




  export type EmploymentDetailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmploymentDetailsWhereInput
    orderBy?: EmploymentDetailsOrderByWithAggregationInput | EmploymentDetailsOrderByWithAggregationInput[]
    by: EmploymentDetailsScalarFieldEnum[] | EmploymentDetailsScalarFieldEnum
    having?: EmploymentDetailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmploymentDetailsCountAggregateInputType | true
    _avg?: EmploymentDetailsAvgAggregateInputType
    _sum?: EmploymentDetailsSumAggregateInputType
    _min?: EmploymentDetailsMinAggregateInputType
    _max?: EmploymentDetailsMaxAggregateInputType
  }

  export type EmploymentDetailsGroupByOutputType = {
    ID: number
    CompanyName: string | null
    Salary: string | null
    CompanyAddress: string | null
    JobTitle: string | null
    CompanyPhone: string | null
    CompanyEmail: string | null
    CountryID: number
    _count: EmploymentDetailsCountAggregateOutputType | null
    _avg: EmploymentDetailsAvgAggregateOutputType | null
    _sum: EmploymentDetailsSumAggregateOutputType | null
    _min: EmploymentDetailsMinAggregateOutputType | null
    _max: EmploymentDetailsMaxAggregateOutputType | null
  }

  type GetEmploymentDetailsGroupByPayload<T extends EmploymentDetailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmploymentDetailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmploymentDetailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmploymentDetailsGroupByOutputType[P]>
            : GetScalarType<T[P], EmploymentDetailsGroupByOutputType[P]>
        }
      >
    >


  export type EmploymentDetailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    CompanyName?: boolean
    Salary?: boolean
    CompanyAddress?: boolean
    JobTitle?: boolean
    CompanyPhone?: boolean
    CompanyEmail?: boolean
    CountryID?: boolean
    Country?: boolean | CountriesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employmentDetails"]>


  export type EmploymentDetailsSelectScalar = {
    ID?: boolean
    CompanyName?: boolean
    Salary?: boolean
    CompanyAddress?: boolean
    JobTitle?: boolean
    CompanyPhone?: boolean
    CompanyEmail?: boolean
    CountryID?: boolean
  }

  export type EmploymentDetailsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Country?: boolean | CountriesDefaultArgs<ExtArgs>
  }

  export type $EmploymentDetailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmploymentDetails"
    objects: {
      Country: Prisma.$CountriesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      ID: number
      CompanyName: string | null
      Salary: string | null
      CompanyAddress: string | null
      JobTitle: string | null
      CompanyPhone: string | null
      CompanyEmail: string | null
      CountryID: number
    }, ExtArgs["result"]["employmentDetails"]>
    composites: {}
  }

  type EmploymentDetailsGetPayload<S extends boolean | null | undefined | EmploymentDetailsDefaultArgs> = $Result.GetResult<Prisma.$EmploymentDetailsPayload, S>

  type EmploymentDetailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmploymentDetailsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmploymentDetailsCountAggregateInputType | true
    }

  export interface EmploymentDetailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmploymentDetails'], meta: { name: 'EmploymentDetails' } }
    /**
     * Find zero or one EmploymentDetails that matches the filter.
     * @param {EmploymentDetailsFindUniqueArgs} args - Arguments to find a EmploymentDetails
     * @example
     * // Get one EmploymentDetails
     * const employmentDetails = await prisma.employmentDetails.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmploymentDetailsFindUniqueArgs>(args: SelectSubset<T, EmploymentDetailsFindUniqueArgs<ExtArgs>>): Prisma__EmploymentDetailsClient<$Result.GetResult<Prisma.$EmploymentDetailsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EmploymentDetails that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EmploymentDetailsFindUniqueOrThrowArgs} args - Arguments to find a EmploymentDetails
     * @example
     * // Get one EmploymentDetails
     * const employmentDetails = await prisma.employmentDetails.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmploymentDetailsFindUniqueOrThrowArgs>(args: SelectSubset<T, EmploymentDetailsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmploymentDetailsClient<$Result.GetResult<Prisma.$EmploymentDetailsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EmploymentDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmploymentDetailsFindFirstArgs} args - Arguments to find a EmploymentDetails
     * @example
     * // Get one EmploymentDetails
     * const employmentDetails = await prisma.employmentDetails.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmploymentDetailsFindFirstArgs>(args?: SelectSubset<T, EmploymentDetailsFindFirstArgs<ExtArgs>>): Prisma__EmploymentDetailsClient<$Result.GetResult<Prisma.$EmploymentDetailsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EmploymentDetails that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmploymentDetailsFindFirstOrThrowArgs} args - Arguments to find a EmploymentDetails
     * @example
     * // Get one EmploymentDetails
     * const employmentDetails = await prisma.employmentDetails.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmploymentDetailsFindFirstOrThrowArgs>(args?: SelectSubset<T, EmploymentDetailsFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmploymentDetailsClient<$Result.GetResult<Prisma.$EmploymentDetailsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EmploymentDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmploymentDetailsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmploymentDetails
     * const employmentDetails = await prisma.employmentDetails.findMany()
     * 
     * // Get first 10 EmploymentDetails
     * const employmentDetails = await prisma.employmentDetails.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const employmentDetailsWithIDOnly = await prisma.employmentDetails.findMany({ select: { ID: true } })
     * 
     */
    findMany<T extends EmploymentDetailsFindManyArgs>(args?: SelectSubset<T, EmploymentDetailsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmploymentDetailsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EmploymentDetails.
     * @param {EmploymentDetailsCreateArgs} args - Arguments to create a EmploymentDetails.
     * @example
     * // Create one EmploymentDetails
     * const EmploymentDetails = await prisma.employmentDetails.create({
     *   data: {
     *     // ... data to create a EmploymentDetails
     *   }
     * })
     * 
     */
    create<T extends EmploymentDetailsCreateArgs>(args: SelectSubset<T, EmploymentDetailsCreateArgs<ExtArgs>>): Prisma__EmploymentDetailsClient<$Result.GetResult<Prisma.$EmploymentDetailsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EmploymentDetails.
     * @param {EmploymentDetailsCreateManyArgs} args - Arguments to create many EmploymentDetails.
     * @example
     * // Create many EmploymentDetails
     * const employmentDetails = await prisma.employmentDetails.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmploymentDetailsCreateManyArgs>(args?: SelectSubset<T, EmploymentDetailsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EmploymentDetails.
     * @param {EmploymentDetailsDeleteArgs} args - Arguments to delete one EmploymentDetails.
     * @example
     * // Delete one EmploymentDetails
     * const EmploymentDetails = await prisma.employmentDetails.delete({
     *   where: {
     *     // ... filter to delete one EmploymentDetails
     *   }
     * })
     * 
     */
    delete<T extends EmploymentDetailsDeleteArgs>(args: SelectSubset<T, EmploymentDetailsDeleteArgs<ExtArgs>>): Prisma__EmploymentDetailsClient<$Result.GetResult<Prisma.$EmploymentDetailsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EmploymentDetails.
     * @param {EmploymentDetailsUpdateArgs} args - Arguments to update one EmploymentDetails.
     * @example
     * // Update one EmploymentDetails
     * const employmentDetails = await prisma.employmentDetails.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmploymentDetailsUpdateArgs>(args: SelectSubset<T, EmploymentDetailsUpdateArgs<ExtArgs>>): Prisma__EmploymentDetailsClient<$Result.GetResult<Prisma.$EmploymentDetailsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EmploymentDetails.
     * @param {EmploymentDetailsDeleteManyArgs} args - Arguments to filter EmploymentDetails to delete.
     * @example
     * // Delete a few EmploymentDetails
     * const { count } = await prisma.employmentDetails.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmploymentDetailsDeleteManyArgs>(args?: SelectSubset<T, EmploymentDetailsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmploymentDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmploymentDetailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmploymentDetails
     * const employmentDetails = await prisma.employmentDetails.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmploymentDetailsUpdateManyArgs>(args: SelectSubset<T, EmploymentDetailsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmploymentDetails.
     * @param {EmploymentDetailsUpsertArgs} args - Arguments to update or create a EmploymentDetails.
     * @example
     * // Update or create a EmploymentDetails
     * const employmentDetails = await prisma.employmentDetails.upsert({
     *   create: {
     *     // ... data to create a EmploymentDetails
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmploymentDetails we want to update
     *   }
     * })
     */
    upsert<T extends EmploymentDetailsUpsertArgs>(args: SelectSubset<T, EmploymentDetailsUpsertArgs<ExtArgs>>): Prisma__EmploymentDetailsClient<$Result.GetResult<Prisma.$EmploymentDetailsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EmploymentDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmploymentDetailsCountArgs} args - Arguments to filter EmploymentDetails to count.
     * @example
     * // Count the number of EmploymentDetails
     * const count = await prisma.employmentDetails.count({
     *   where: {
     *     // ... the filter for the EmploymentDetails we want to count
     *   }
     * })
    **/
    count<T extends EmploymentDetailsCountArgs>(
      args?: Subset<T, EmploymentDetailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmploymentDetailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmploymentDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmploymentDetailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmploymentDetailsAggregateArgs>(args: Subset<T, EmploymentDetailsAggregateArgs>): Prisma.PrismaPromise<GetEmploymentDetailsAggregateType<T>>

    /**
     * Group by EmploymentDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmploymentDetailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmploymentDetailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmploymentDetailsGroupByArgs['orderBy'] }
        : { orderBy?: EmploymentDetailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmploymentDetailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmploymentDetailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmploymentDetails model
   */
  readonly fields: EmploymentDetailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmploymentDetails.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmploymentDetailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Country<T extends CountriesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CountriesDefaultArgs<ExtArgs>>): Prisma__CountriesClient<$Result.GetResult<Prisma.$CountriesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmploymentDetails model
   */ 
  interface EmploymentDetailsFieldRefs {
    readonly ID: FieldRef<"EmploymentDetails", 'Int'>
    readonly CompanyName: FieldRef<"EmploymentDetails", 'String'>
    readonly Salary: FieldRef<"EmploymentDetails", 'String'>
    readonly CompanyAddress: FieldRef<"EmploymentDetails", 'String'>
    readonly JobTitle: FieldRef<"EmploymentDetails", 'String'>
    readonly CompanyPhone: FieldRef<"EmploymentDetails", 'String'>
    readonly CompanyEmail: FieldRef<"EmploymentDetails", 'String'>
    readonly CountryID: FieldRef<"EmploymentDetails", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * EmploymentDetails findUnique
   */
  export type EmploymentDetailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmploymentDetails
     */
    select?: EmploymentDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmploymentDetailsInclude<ExtArgs> | null
    /**
     * Filter, which EmploymentDetails to fetch.
     */
    where: EmploymentDetailsWhereUniqueInput
  }

  /**
   * EmploymentDetails findUniqueOrThrow
   */
  export type EmploymentDetailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmploymentDetails
     */
    select?: EmploymentDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmploymentDetailsInclude<ExtArgs> | null
    /**
     * Filter, which EmploymentDetails to fetch.
     */
    where: EmploymentDetailsWhereUniqueInput
  }

  /**
   * EmploymentDetails findFirst
   */
  export type EmploymentDetailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmploymentDetails
     */
    select?: EmploymentDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmploymentDetailsInclude<ExtArgs> | null
    /**
     * Filter, which EmploymentDetails to fetch.
     */
    where?: EmploymentDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmploymentDetails to fetch.
     */
    orderBy?: EmploymentDetailsOrderByWithRelationInput | EmploymentDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmploymentDetails.
     */
    cursor?: EmploymentDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmploymentDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmploymentDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmploymentDetails.
     */
    distinct?: EmploymentDetailsScalarFieldEnum | EmploymentDetailsScalarFieldEnum[]
  }

  /**
   * EmploymentDetails findFirstOrThrow
   */
  export type EmploymentDetailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmploymentDetails
     */
    select?: EmploymentDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmploymentDetailsInclude<ExtArgs> | null
    /**
     * Filter, which EmploymentDetails to fetch.
     */
    where?: EmploymentDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmploymentDetails to fetch.
     */
    orderBy?: EmploymentDetailsOrderByWithRelationInput | EmploymentDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmploymentDetails.
     */
    cursor?: EmploymentDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmploymentDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmploymentDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmploymentDetails.
     */
    distinct?: EmploymentDetailsScalarFieldEnum | EmploymentDetailsScalarFieldEnum[]
  }

  /**
   * EmploymentDetails findMany
   */
  export type EmploymentDetailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmploymentDetails
     */
    select?: EmploymentDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmploymentDetailsInclude<ExtArgs> | null
    /**
     * Filter, which EmploymentDetails to fetch.
     */
    where?: EmploymentDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmploymentDetails to fetch.
     */
    orderBy?: EmploymentDetailsOrderByWithRelationInput | EmploymentDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmploymentDetails.
     */
    cursor?: EmploymentDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmploymentDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmploymentDetails.
     */
    skip?: number
    distinct?: EmploymentDetailsScalarFieldEnum | EmploymentDetailsScalarFieldEnum[]
  }

  /**
   * EmploymentDetails create
   */
  export type EmploymentDetailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmploymentDetails
     */
    select?: EmploymentDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmploymentDetailsInclude<ExtArgs> | null
    /**
     * The data needed to create a EmploymentDetails.
     */
    data: XOR<EmploymentDetailsCreateInput, EmploymentDetailsUncheckedCreateInput>
  }

  /**
   * EmploymentDetails createMany
   */
  export type EmploymentDetailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmploymentDetails.
     */
    data: EmploymentDetailsCreateManyInput | EmploymentDetailsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmploymentDetails update
   */
  export type EmploymentDetailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmploymentDetails
     */
    select?: EmploymentDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmploymentDetailsInclude<ExtArgs> | null
    /**
     * The data needed to update a EmploymentDetails.
     */
    data: XOR<EmploymentDetailsUpdateInput, EmploymentDetailsUncheckedUpdateInput>
    /**
     * Choose, which EmploymentDetails to update.
     */
    where: EmploymentDetailsWhereUniqueInput
  }

  /**
   * EmploymentDetails updateMany
   */
  export type EmploymentDetailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmploymentDetails.
     */
    data: XOR<EmploymentDetailsUpdateManyMutationInput, EmploymentDetailsUncheckedUpdateManyInput>
    /**
     * Filter which EmploymentDetails to update
     */
    where?: EmploymentDetailsWhereInput
  }

  /**
   * EmploymentDetails upsert
   */
  export type EmploymentDetailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmploymentDetails
     */
    select?: EmploymentDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmploymentDetailsInclude<ExtArgs> | null
    /**
     * The filter to search for the EmploymentDetails to update in case it exists.
     */
    where: EmploymentDetailsWhereUniqueInput
    /**
     * In case the EmploymentDetails found by the `where` argument doesn't exist, create a new EmploymentDetails with this data.
     */
    create: XOR<EmploymentDetailsCreateInput, EmploymentDetailsUncheckedCreateInput>
    /**
     * In case the EmploymentDetails was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmploymentDetailsUpdateInput, EmploymentDetailsUncheckedUpdateInput>
  }

  /**
   * EmploymentDetails delete
   */
  export type EmploymentDetailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmploymentDetails
     */
    select?: EmploymentDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmploymentDetailsInclude<ExtArgs> | null
    /**
     * Filter which EmploymentDetails to delete.
     */
    where: EmploymentDetailsWhereUniqueInput
  }

  /**
   * EmploymentDetails deleteMany
   */
  export type EmploymentDetailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmploymentDetails to delete
     */
    where?: EmploymentDetailsWhereInput
  }

  /**
   * EmploymentDetails without action
   */
  export type EmploymentDetailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmploymentDetails
     */
    select?: EmploymentDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmploymentDetailsInclude<ExtArgs> | null
  }


  /**
   * Model VehicleDetails
   */

  export type AggregateVehicleDetails = {
    _count: VehicleDetailsCountAggregateOutputType | null
    _avg: VehicleDetailsAvgAggregateOutputType | null
    _sum: VehicleDetailsSumAggregateOutputType | null
    _min: VehicleDetailsMinAggregateOutputType | null
    _max: VehicleDetailsMaxAggregateOutputType | null
  }

  export type VehicleDetailsAvgAggregateOutputType = {
    ID: number | null
    CountryID: number | null
  }

  export type VehicleDetailsSumAggregateOutputType = {
    ID: number | null
    CountryID: number | null
  }

  export type VehicleDetailsMinAggregateOutputType = {
    ID: number | null
    VehicleName: string | null
    LicensePlate: string | null
    VIN: string | null
    Color: string | null
    CountryID: number | null
  }

  export type VehicleDetailsMaxAggregateOutputType = {
    ID: number | null
    VehicleName: string | null
    LicensePlate: string | null
    VIN: string | null
    Color: string | null
    CountryID: number | null
  }

  export type VehicleDetailsCountAggregateOutputType = {
    ID: number
    VehicleName: number
    LicensePlate: number
    VIN: number
    Color: number
    CountryID: number
    _all: number
  }


  export type VehicleDetailsAvgAggregateInputType = {
    ID?: true
    CountryID?: true
  }

  export type VehicleDetailsSumAggregateInputType = {
    ID?: true
    CountryID?: true
  }

  export type VehicleDetailsMinAggregateInputType = {
    ID?: true
    VehicleName?: true
    LicensePlate?: true
    VIN?: true
    Color?: true
    CountryID?: true
  }

  export type VehicleDetailsMaxAggregateInputType = {
    ID?: true
    VehicleName?: true
    LicensePlate?: true
    VIN?: true
    Color?: true
    CountryID?: true
  }

  export type VehicleDetailsCountAggregateInputType = {
    ID?: true
    VehicleName?: true
    LicensePlate?: true
    VIN?: true
    Color?: true
    CountryID?: true
    _all?: true
  }

  export type VehicleDetailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VehicleDetails to aggregate.
     */
    where?: VehicleDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VehicleDetails to fetch.
     */
    orderBy?: VehicleDetailsOrderByWithRelationInput | VehicleDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VehicleDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VehicleDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VehicleDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VehicleDetails
    **/
    _count?: true | VehicleDetailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VehicleDetailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VehicleDetailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VehicleDetailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VehicleDetailsMaxAggregateInputType
  }

  export type GetVehicleDetailsAggregateType<T extends VehicleDetailsAggregateArgs> = {
        [P in keyof T & keyof AggregateVehicleDetails]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVehicleDetails[P]>
      : GetScalarType<T[P], AggregateVehicleDetails[P]>
  }




  export type VehicleDetailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VehicleDetailsWhereInput
    orderBy?: VehicleDetailsOrderByWithAggregationInput | VehicleDetailsOrderByWithAggregationInput[]
    by: VehicleDetailsScalarFieldEnum[] | VehicleDetailsScalarFieldEnum
    having?: VehicleDetailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VehicleDetailsCountAggregateInputType | true
    _avg?: VehicleDetailsAvgAggregateInputType
    _sum?: VehicleDetailsSumAggregateInputType
    _min?: VehicleDetailsMinAggregateInputType
    _max?: VehicleDetailsMaxAggregateInputType
  }

  export type VehicleDetailsGroupByOutputType = {
    ID: number
    VehicleName: string | null
    LicensePlate: string | null
    VIN: string | null
    Color: string | null
    CountryID: number
    _count: VehicleDetailsCountAggregateOutputType | null
    _avg: VehicleDetailsAvgAggregateOutputType | null
    _sum: VehicleDetailsSumAggregateOutputType | null
    _min: VehicleDetailsMinAggregateOutputType | null
    _max: VehicleDetailsMaxAggregateOutputType | null
  }

  type GetVehicleDetailsGroupByPayload<T extends VehicleDetailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VehicleDetailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VehicleDetailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VehicleDetailsGroupByOutputType[P]>
            : GetScalarType<T[P], VehicleDetailsGroupByOutputType[P]>
        }
      >
    >


  export type VehicleDetailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    ID?: boolean
    VehicleName?: boolean
    LicensePlate?: boolean
    VIN?: boolean
    Color?: boolean
    CountryID?: boolean
    Country?: boolean | CountriesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehicleDetails"]>


  export type VehicleDetailsSelectScalar = {
    ID?: boolean
    VehicleName?: boolean
    LicensePlate?: boolean
    VIN?: boolean
    Color?: boolean
    CountryID?: boolean
  }

  export type VehicleDetailsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Country?: boolean | CountriesDefaultArgs<ExtArgs>
  }

  export type $VehicleDetailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VehicleDetails"
    objects: {
      Country: Prisma.$CountriesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      ID: number
      VehicleName: string | null
      LicensePlate: string | null
      VIN: string | null
      Color: string | null
      CountryID: number
    }, ExtArgs["result"]["vehicleDetails"]>
    composites: {}
  }

  type VehicleDetailsGetPayload<S extends boolean | null | undefined | VehicleDetailsDefaultArgs> = $Result.GetResult<Prisma.$VehicleDetailsPayload, S>

  type VehicleDetailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<VehicleDetailsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: VehicleDetailsCountAggregateInputType | true
    }

  export interface VehicleDetailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VehicleDetails'], meta: { name: 'VehicleDetails' } }
    /**
     * Find zero or one VehicleDetails that matches the filter.
     * @param {VehicleDetailsFindUniqueArgs} args - Arguments to find a VehicleDetails
     * @example
     * // Get one VehicleDetails
     * const vehicleDetails = await prisma.vehicleDetails.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VehicleDetailsFindUniqueArgs>(args: SelectSubset<T, VehicleDetailsFindUniqueArgs<ExtArgs>>): Prisma__VehicleDetailsClient<$Result.GetResult<Prisma.$VehicleDetailsPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one VehicleDetails that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {VehicleDetailsFindUniqueOrThrowArgs} args - Arguments to find a VehicleDetails
     * @example
     * // Get one VehicleDetails
     * const vehicleDetails = await prisma.vehicleDetails.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VehicleDetailsFindUniqueOrThrowArgs>(args: SelectSubset<T, VehicleDetailsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VehicleDetailsClient<$Result.GetResult<Prisma.$VehicleDetailsPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first VehicleDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleDetailsFindFirstArgs} args - Arguments to find a VehicleDetails
     * @example
     * // Get one VehicleDetails
     * const vehicleDetails = await prisma.vehicleDetails.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VehicleDetailsFindFirstArgs>(args?: SelectSubset<T, VehicleDetailsFindFirstArgs<ExtArgs>>): Prisma__VehicleDetailsClient<$Result.GetResult<Prisma.$VehicleDetailsPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first VehicleDetails that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleDetailsFindFirstOrThrowArgs} args - Arguments to find a VehicleDetails
     * @example
     * // Get one VehicleDetails
     * const vehicleDetails = await prisma.vehicleDetails.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VehicleDetailsFindFirstOrThrowArgs>(args?: SelectSubset<T, VehicleDetailsFindFirstOrThrowArgs<ExtArgs>>): Prisma__VehicleDetailsClient<$Result.GetResult<Prisma.$VehicleDetailsPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more VehicleDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleDetailsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VehicleDetails
     * const vehicleDetails = await prisma.vehicleDetails.findMany()
     * 
     * // Get first 10 VehicleDetails
     * const vehicleDetails = await prisma.vehicleDetails.findMany({ take: 10 })
     * 
     * // Only select the `ID`
     * const vehicleDetailsWithIDOnly = await prisma.vehicleDetails.findMany({ select: { ID: true } })
     * 
     */
    findMany<T extends VehicleDetailsFindManyArgs>(args?: SelectSubset<T, VehicleDetailsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehicleDetailsPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a VehicleDetails.
     * @param {VehicleDetailsCreateArgs} args - Arguments to create a VehicleDetails.
     * @example
     * // Create one VehicleDetails
     * const VehicleDetails = await prisma.vehicleDetails.create({
     *   data: {
     *     // ... data to create a VehicleDetails
     *   }
     * })
     * 
     */
    create<T extends VehicleDetailsCreateArgs>(args: SelectSubset<T, VehicleDetailsCreateArgs<ExtArgs>>): Prisma__VehicleDetailsClient<$Result.GetResult<Prisma.$VehicleDetailsPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many VehicleDetails.
     * @param {VehicleDetailsCreateManyArgs} args - Arguments to create many VehicleDetails.
     * @example
     * // Create many VehicleDetails
     * const vehicleDetails = await prisma.vehicleDetails.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VehicleDetailsCreateManyArgs>(args?: SelectSubset<T, VehicleDetailsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a VehicleDetails.
     * @param {VehicleDetailsDeleteArgs} args - Arguments to delete one VehicleDetails.
     * @example
     * // Delete one VehicleDetails
     * const VehicleDetails = await prisma.vehicleDetails.delete({
     *   where: {
     *     // ... filter to delete one VehicleDetails
     *   }
     * })
     * 
     */
    delete<T extends VehicleDetailsDeleteArgs>(args: SelectSubset<T, VehicleDetailsDeleteArgs<ExtArgs>>): Prisma__VehicleDetailsClient<$Result.GetResult<Prisma.$VehicleDetailsPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one VehicleDetails.
     * @param {VehicleDetailsUpdateArgs} args - Arguments to update one VehicleDetails.
     * @example
     * // Update one VehicleDetails
     * const vehicleDetails = await prisma.vehicleDetails.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VehicleDetailsUpdateArgs>(args: SelectSubset<T, VehicleDetailsUpdateArgs<ExtArgs>>): Prisma__VehicleDetailsClient<$Result.GetResult<Prisma.$VehicleDetailsPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more VehicleDetails.
     * @param {VehicleDetailsDeleteManyArgs} args - Arguments to filter VehicleDetails to delete.
     * @example
     * // Delete a few VehicleDetails
     * const { count } = await prisma.vehicleDetails.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VehicleDetailsDeleteManyArgs>(args?: SelectSubset<T, VehicleDetailsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VehicleDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleDetailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VehicleDetails
     * const vehicleDetails = await prisma.vehicleDetails.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VehicleDetailsUpdateManyArgs>(args: SelectSubset<T, VehicleDetailsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one VehicleDetails.
     * @param {VehicleDetailsUpsertArgs} args - Arguments to update or create a VehicleDetails.
     * @example
     * // Update or create a VehicleDetails
     * const vehicleDetails = await prisma.vehicleDetails.upsert({
     *   create: {
     *     // ... data to create a VehicleDetails
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VehicleDetails we want to update
     *   }
     * })
     */
    upsert<T extends VehicleDetailsUpsertArgs>(args: SelectSubset<T, VehicleDetailsUpsertArgs<ExtArgs>>): Prisma__VehicleDetailsClient<$Result.GetResult<Prisma.$VehicleDetailsPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of VehicleDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleDetailsCountArgs} args - Arguments to filter VehicleDetails to count.
     * @example
     * // Count the number of VehicleDetails
     * const count = await prisma.vehicleDetails.count({
     *   where: {
     *     // ... the filter for the VehicleDetails we want to count
     *   }
     * })
    **/
    count<T extends VehicleDetailsCountArgs>(
      args?: Subset<T, VehicleDetailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VehicleDetailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VehicleDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleDetailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VehicleDetailsAggregateArgs>(args: Subset<T, VehicleDetailsAggregateArgs>): Prisma.PrismaPromise<GetVehicleDetailsAggregateType<T>>

    /**
     * Group by VehicleDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleDetailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VehicleDetailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VehicleDetailsGroupByArgs['orderBy'] }
        : { orderBy?: VehicleDetailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VehicleDetailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVehicleDetailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VehicleDetails model
   */
  readonly fields: VehicleDetailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VehicleDetails.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VehicleDetailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Country<T extends CountriesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CountriesDefaultArgs<ExtArgs>>): Prisma__CountriesClient<$Result.GetResult<Prisma.$CountriesPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VehicleDetails model
   */ 
  interface VehicleDetailsFieldRefs {
    readonly ID: FieldRef<"VehicleDetails", 'Int'>
    readonly VehicleName: FieldRef<"VehicleDetails", 'String'>
    readonly LicensePlate: FieldRef<"VehicleDetails", 'String'>
    readonly VIN: FieldRef<"VehicleDetails", 'String'>
    readonly Color: FieldRef<"VehicleDetails", 'String'>
    readonly CountryID: FieldRef<"VehicleDetails", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * VehicleDetails findUnique
   */
  export type VehicleDetailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleDetails
     */
    select?: VehicleDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleDetailsInclude<ExtArgs> | null
    /**
     * Filter, which VehicleDetails to fetch.
     */
    where: VehicleDetailsWhereUniqueInput
  }

  /**
   * VehicleDetails findUniqueOrThrow
   */
  export type VehicleDetailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleDetails
     */
    select?: VehicleDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleDetailsInclude<ExtArgs> | null
    /**
     * Filter, which VehicleDetails to fetch.
     */
    where: VehicleDetailsWhereUniqueInput
  }

  /**
   * VehicleDetails findFirst
   */
  export type VehicleDetailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleDetails
     */
    select?: VehicleDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleDetailsInclude<ExtArgs> | null
    /**
     * Filter, which VehicleDetails to fetch.
     */
    where?: VehicleDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VehicleDetails to fetch.
     */
    orderBy?: VehicleDetailsOrderByWithRelationInput | VehicleDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VehicleDetails.
     */
    cursor?: VehicleDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VehicleDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VehicleDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VehicleDetails.
     */
    distinct?: VehicleDetailsScalarFieldEnum | VehicleDetailsScalarFieldEnum[]
  }

  /**
   * VehicleDetails findFirstOrThrow
   */
  export type VehicleDetailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleDetails
     */
    select?: VehicleDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleDetailsInclude<ExtArgs> | null
    /**
     * Filter, which VehicleDetails to fetch.
     */
    where?: VehicleDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VehicleDetails to fetch.
     */
    orderBy?: VehicleDetailsOrderByWithRelationInput | VehicleDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VehicleDetails.
     */
    cursor?: VehicleDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VehicleDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VehicleDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VehicleDetails.
     */
    distinct?: VehicleDetailsScalarFieldEnum | VehicleDetailsScalarFieldEnum[]
  }

  /**
   * VehicleDetails findMany
   */
  export type VehicleDetailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleDetails
     */
    select?: VehicleDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleDetailsInclude<ExtArgs> | null
    /**
     * Filter, which VehicleDetails to fetch.
     */
    where?: VehicleDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VehicleDetails to fetch.
     */
    orderBy?: VehicleDetailsOrderByWithRelationInput | VehicleDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VehicleDetails.
     */
    cursor?: VehicleDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VehicleDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VehicleDetails.
     */
    skip?: number
    distinct?: VehicleDetailsScalarFieldEnum | VehicleDetailsScalarFieldEnum[]
  }

  /**
   * VehicleDetails create
   */
  export type VehicleDetailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleDetails
     */
    select?: VehicleDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleDetailsInclude<ExtArgs> | null
    /**
     * The data needed to create a VehicleDetails.
     */
    data: XOR<VehicleDetailsCreateInput, VehicleDetailsUncheckedCreateInput>
  }

  /**
   * VehicleDetails createMany
   */
  export type VehicleDetailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VehicleDetails.
     */
    data: VehicleDetailsCreateManyInput | VehicleDetailsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VehicleDetails update
   */
  export type VehicleDetailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleDetails
     */
    select?: VehicleDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleDetailsInclude<ExtArgs> | null
    /**
     * The data needed to update a VehicleDetails.
     */
    data: XOR<VehicleDetailsUpdateInput, VehicleDetailsUncheckedUpdateInput>
    /**
     * Choose, which VehicleDetails to update.
     */
    where: VehicleDetailsWhereUniqueInput
  }

  /**
   * VehicleDetails updateMany
   */
  export type VehicleDetailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VehicleDetails.
     */
    data: XOR<VehicleDetailsUpdateManyMutationInput, VehicleDetailsUncheckedUpdateManyInput>
    /**
     * Filter which VehicleDetails to update
     */
    where?: VehicleDetailsWhereInput
  }

  /**
   * VehicleDetails upsert
   */
  export type VehicleDetailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleDetails
     */
    select?: VehicleDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleDetailsInclude<ExtArgs> | null
    /**
     * The filter to search for the VehicleDetails to update in case it exists.
     */
    where: VehicleDetailsWhereUniqueInput
    /**
     * In case the VehicleDetails found by the `where` argument doesn't exist, create a new VehicleDetails with this data.
     */
    create: XOR<VehicleDetailsCreateInput, VehicleDetailsUncheckedCreateInput>
    /**
     * In case the VehicleDetails was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VehicleDetailsUpdateInput, VehicleDetailsUncheckedUpdateInput>
  }

  /**
   * VehicleDetails delete
   */
  export type VehicleDetailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleDetails
     */
    select?: VehicleDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleDetailsInclude<ExtArgs> | null
    /**
     * Filter which VehicleDetails to delete.
     */
    where: VehicleDetailsWhereUniqueInput
  }

  /**
   * VehicleDetails deleteMany
   */
  export type VehicleDetailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VehicleDetails to delete
     */
    where?: VehicleDetailsWhereInput
  }

  /**
   * VehicleDetails without action
   */
  export type VehicleDetailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleDetails
     */
    select?: VehicleDetailsSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleDetailsInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const CountriesScalarFieldEnum: {
    CountryID: 'CountryID',
    CountryName: 'CountryName'
  };

  export type CountriesScalarFieldEnum = (typeof CountriesScalarFieldEnum)[keyof typeof CountriesScalarFieldEnum]


  export const PersonalDetailsScalarFieldEnum: {
    ID: 'ID',
    Name: 'Name',
    Address: 'Address',
    Postcode: 'Postcode',
    City: 'City',
    DateOfBirth: 'DateOfBirth',
    Gender: 'Gender',
    Phone: 'Phone',
    MothersMaidenName: 'MothersMaidenName',
    Email: 'Email',
    Ethnicity: 'Ethnicity',
    ZodiacSign: 'ZodiacSign',
    Age: 'Age',
    Height: 'Height',
    Weight: 'Weight',
    EyeColor: 'EyeColor',
    HairColor: 'HairColor',
    CountryID: 'CountryID'
  };

  export type PersonalDetailsScalarFieldEnum = (typeof PersonalDetailsScalarFieldEnum)[keyof typeof PersonalDetailsScalarFieldEnum]


  export const FinancialDetailsScalarFieldEnum: {
    ID: 'ID',
    CreditCardType: 'CreditCardType',
    CreditCardNumber: 'CreditCardNumber',
    CreditCardExpiry: 'CreditCardExpiry',
    CreditCardCVV2: 'CreditCardCVV2',
    CountryID: 'CountryID'
  };

  export type FinancialDetailsScalarFieldEnum = (typeof FinancialDetailsScalarFieldEnum)[keyof typeof FinancialDetailsScalarFieldEnum]


  export const InternetDetailsScalarFieldEnum: {
    ID: 'ID',
    UserName: 'UserName',
    Password: 'Password',
    IPv4Address: 'IPv4Address',
    IPv6Address: 'IPv6Address',
    UserAgent: 'UserAgent',
    CountryID: 'CountryID'
  };

  export type InternetDetailsScalarFieldEnum = (typeof InternetDetailsScalarFieldEnum)[keyof typeof InternetDetailsScalarFieldEnum]


  export const EducationDetailsScalarFieldEnum: {
    ID: 'ID',
    Qualification: 'Qualification',
    Institution: 'Institution',
    CountryID: 'CountryID'
  };

  export type EducationDetailsScalarFieldEnum = (typeof EducationDetailsScalarFieldEnum)[keyof typeof EducationDetailsScalarFieldEnum]


  export const EmploymentDetailsScalarFieldEnum: {
    ID: 'ID',
    CompanyName: 'CompanyName',
    Salary: 'Salary',
    CompanyAddress: 'CompanyAddress',
    JobTitle: 'JobTitle',
    CompanyPhone: 'CompanyPhone',
    CompanyEmail: 'CompanyEmail',
    CountryID: 'CountryID'
  };

  export type EmploymentDetailsScalarFieldEnum = (typeof EmploymentDetailsScalarFieldEnum)[keyof typeof EmploymentDetailsScalarFieldEnum]


  export const VehicleDetailsScalarFieldEnum: {
    ID: 'ID',
    VehicleName: 'VehicleName',
    LicensePlate: 'LicensePlate',
    VIN: 'VIN',
    Color: 'Color',
    CountryID: 'CountryID'
  };

  export type VehicleDetailsScalarFieldEnum = (typeof VehicleDetailsScalarFieldEnum)[keyof typeof VehicleDetailsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type CountriesWhereInput = {
    AND?: CountriesWhereInput | CountriesWhereInput[]
    OR?: CountriesWhereInput[]
    NOT?: CountriesWhereInput | CountriesWhereInput[]
    CountryID?: IntFilter<"Countries"> | number
    CountryName?: StringFilter<"Countries"> | string
    PersonalDetails?: PersonalDetailsListRelationFilter
    FinancialDetails?: FinancialDetailsListRelationFilter
    InternetDetails?: InternetDetailsListRelationFilter
    EducationDetails?: EducationDetailsListRelationFilter
    EmploymentDetails?: EmploymentDetailsListRelationFilter
    VehicleDetails?: VehicleDetailsListRelationFilter
  }

  export type CountriesOrderByWithRelationInput = {
    CountryID?: SortOrder
    CountryName?: SortOrder
    PersonalDetails?: PersonalDetailsOrderByRelationAggregateInput
    FinancialDetails?: FinancialDetailsOrderByRelationAggregateInput
    InternetDetails?: InternetDetailsOrderByRelationAggregateInput
    EducationDetails?: EducationDetailsOrderByRelationAggregateInput
    EmploymentDetails?: EmploymentDetailsOrderByRelationAggregateInput
    VehicleDetails?: VehicleDetailsOrderByRelationAggregateInput
  }

  export type CountriesWhereUniqueInput = Prisma.AtLeast<{
    CountryID?: number
    CountryName?: string
    AND?: CountriesWhereInput | CountriesWhereInput[]
    OR?: CountriesWhereInput[]
    NOT?: CountriesWhereInput | CountriesWhereInput[]
    PersonalDetails?: PersonalDetailsListRelationFilter
    FinancialDetails?: FinancialDetailsListRelationFilter
    InternetDetails?: InternetDetailsListRelationFilter
    EducationDetails?: EducationDetailsListRelationFilter
    EmploymentDetails?: EmploymentDetailsListRelationFilter
    VehicleDetails?: VehicleDetailsListRelationFilter
  }, "CountryID" | "CountryName">

  export type CountriesOrderByWithAggregationInput = {
    CountryID?: SortOrder
    CountryName?: SortOrder
    _count?: CountriesCountOrderByAggregateInput
    _avg?: CountriesAvgOrderByAggregateInput
    _max?: CountriesMaxOrderByAggregateInput
    _min?: CountriesMinOrderByAggregateInput
    _sum?: CountriesSumOrderByAggregateInput
  }

  export type CountriesScalarWhereWithAggregatesInput = {
    AND?: CountriesScalarWhereWithAggregatesInput | CountriesScalarWhereWithAggregatesInput[]
    OR?: CountriesScalarWhereWithAggregatesInput[]
    NOT?: CountriesScalarWhereWithAggregatesInput | CountriesScalarWhereWithAggregatesInput[]
    CountryID?: IntWithAggregatesFilter<"Countries"> | number
    CountryName?: StringWithAggregatesFilter<"Countries"> | string
  }

  export type PersonalDetailsWhereInput = {
    AND?: PersonalDetailsWhereInput | PersonalDetailsWhereInput[]
    OR?: PersonalDetailsWhereInput[]
    NOT?: PersonalDetailsWhereInput | PersonalDetailsWhereInput[]
    ID?: IntFilter<"PersonalDetails"> | number
    Name?: StringNullableFilter<"PersonalDetails"> | string | null
    Address?: StringNullableFilter<"PersonalDetails"> | string | null
    Postcode?: StringNullableFilter<"PersonalDetails"> | string | null
    City?: StringNullableFilter<"PersonalDetails"> | string | null
    DateOfBirth?: DateTimeNullableFilter<"PersonalDetails"> | Date | string | null
    Gender?: StringNullableFilter<"PersonalDetails"> | string | null
    Phone?: StringNullableFilter<"PersonalDetails"> | string | null
    MothersMaidenName?: StringNullableFilter<"PersonalDetails"> | string | null
    Email?: StringNullableFilter<"PersonalDetails"> | string | null
    Ethnicity?: StringNullableFilter<"PersonalDetails"> | string | null
    ZodiacSign?: StringNullableFilter<"PersonalDetails"> | string | null
    Age?: IntNullableFilter<"PersonalDetails"> | number | null
    Height?: FloatNullableFilter<"PersonalDetails"> | number | null
    Weight?: FloatNullableFilter<"PersonalDetails"> | number | null
    EyeColor?: StringNullableFilter<"PersonalDetails"> | string | null
    HairColor?: StringNullableFilter<"PersonalDetails"> | string | null
    CountryID?: IntFilter<"PersonalDetails"> | number
    Country?: XOR<CountriesRelationFilter, CountriesWhereInput>
  }

  export type PersonalDetailsOrderByWithRelationInput = {
    ID?: SortOrder
    Name?: SortOrderInput | SortOrder
    Address?: SortOrderInput | SortOrder
    Postcode?: SortOrderInput | SortOrder
    City?: SortOrderInput | SortOrder
    DateOfBirth?: SortOrderInput | SortOrder
    Gender?: SortOrderInput | SortOrder
    Phone?: SortOrderInput | SortOrder
    MothersMaidenName?: SortOrderInput | SortOrder
    Email?: SortOrderInput | SortOrder
    Ethnicity?: SortOrderInput | SortOrder
    ZodiacSign?: SortOrderInput | SortOrder
    Age?: SortOrderInput | SortOrder
    Height?: SortOrderInput | SortOrder
    Weight?: SortOrderInput | SortOrder
    EyeColor?: SortOrderInput | SortOrder
    HairColor?: SortOrderInput | SortOrder
    CountryID?: SortOrder
    Country?: CountriesOrderByWithRelationInput
  }

  export type PersonalDetailsWhereUniqueInput = Prisma.AtLeast<{
    ID?: number
    Phone?: string
    Email?: string
    AND?: PersonalDetailsWhereInput | PersonalDetailsWhereInput[]
    OR?: PersonalDetailsWhereInput[]
    NOT?: PersonalDetailsWhereInput | PersonalDetailsWhereInput[]
    Name?: StringNullableFilter<"PersonalDetails"> | string | null
    Address?: StringNullableFilter<"PersonalDetails"> | string | null
    Postcode?: StringNullableFilter<"PersonalDetails"> | string | null
    City?: StringNullableFilter<"PersonalDetails"> | string | null
    DateOfBirth?: DateTimeNullableFilter<"PersonalDetails"> | Date | string | null
    Gender?: StringNullableFilter<"PersonalDetails"> | string | null
    MothersMaidenName?: StringNullableFilter<"PersonalDetails"> | string | null
    Ethnicity?: StringNullableFilter<"PersonalDetails"> | string | null
    ZodiacSign?: StringNullableFilter<"PersonalDetails"> | string | null
    Age?: IntNullableFilter<"PersonalDetails"> | number | null
    Height?: FloatNullableFilter<"PersonalDetails"> | number | null
    Weight?: FloatNullableFilter<"PersonalDetails"> | number | null
    EyeColor?: StringNullableFilter<"PersonalDetails"> | string | null
    HairColor?: StringNullableFilter<"PersonalDetails"> | string | null
    CountryID?: IntFilter<"PersonalDetails"> | number
    Country?: XOR<CountriesRelationFilter, CountriesWhereInput>
  }, "ID" | "Phone" | "Email">

  export type PersonalDetailsOrderByWithAggregationInput = {
    ID?: SortOrder
    Name?: SortOrderInput | SortOrder
    Address?: SortOrderInput | SortOrder
    Postcode?: SortOrderInput | SortOrder
    City?: SortOrderInput | SortOrder
    DateOfBirth?: SortOrderInput | SortOrder
    Gender?: SortOrderInput | SortOrder
    Phone?: SortOrderInput | SortOrder
    MothersMaidenName?: SortOrderInput | SortOrder
    Email?: SortOrderInput | SortOrder
    Ethnicity?: SortOrderInput | SortOrder
    ZodiacSign?: SortOrderInput | SortOrder
    Age?: SortOrderInput | SortOrder
    Height?: SortOrderInput | SortOrder
    Weight?: SortOrderInput | SortOrder
    EyeColor?: SortOrderInput | SortOrder
    HairColor?: SortOrderInput | SortOrder
    CountryID?: SortOrder
    _count?: PersonalDetailsCountOrderByAggregateInput
    _avg?: PersonalDetailsAvgOrderByAggregateInput
    _max?: PersonalDetailsMaxOrderByAggregateInput
    _min?: PersonalDetailsMinOrderByAggregateInput
    _sum?: PersonalDetailsSumOrderByAggregateInput
  }

  export type PersonalDetailsScalarWhereWithAggregatesInput = {
    AND?: PersonalDetailsScalarWhereWithAggregatesInput | PersonalDetailsScalarWhereWithAggregatesInput[]
    OR?: PersonalDetailsScalarWhereWithAggregatesInput[]
    NOT?: PersonalDetailsScalarWhereWithAggregatesInput | PersonalDetailsScalarWhereWithAggregatesInput[]
    ID?: IntWithAggregatesFilter<"PersonalDetails"> | number
    Name?: StringNullableWithAggregatesFilter<"PersonalDetails"> | string | null
    Address?: StringNullableWithAggregatesFilter<"PersonalDetails"> | string | null
    Postcode?: StringNullableWithAggregatesFilter<"PersonalDetails"> | string | null
    City?: StringNullableWithAggregatesFilter<"PersonalDetails"> | string | null
    DateOfBirth?: DateTimeNullableWithAggregatesFilter<"PersonalDetails"> | Date | string | null
    Gender?: StringNullableWithAggregatesFilter<"PersonalDetails"> | string | null
    Phone?: StringNullableWithAggregatesFilter<"PersonalDetails"> | string | null
    MothersMaidenName?: StringNullableWithAggregatesFilter<"PersonalDetails"> | string | null
    Email?: StringNullableWithAggregatesFilter<"PersonalDetails"> | string | null
    Ethnicity?: StringNullableWithAggregatesFilter<"PersonalDetails"> | string | null
    ZodiacSign?: StringNullableWithAggregatesFilter<"PersonalDetails"> | string | null
    Age?: IntNullableWithAggregatesFilter<"PersonalDetails"> | number | null
    Height?: FloatNullableWithAggregatesFilter<"PersonalDetails"> | number | null
    Weight?: FloatNullableWithAggregatesFilter<"PersonalDetails"> | number | null
    EyeColor?: StringNullableWithAggregatesFilter<"PersonalDetails"> | string | null
    HairColor?: StringNullableWithAggregatesFilter<"PersonalDetails"> | string | null
    CountryID?: IntWithAggregatesFilter<"PersonalDetails"> | number
  }

  export type FinancialDetailsWhereInput = {
    AND?: FinancialDetailsWhereInput | FinancialDetailsWhereInput[]
    OR?: FinancialDetailsWhereInput[]
    NOT?: FinancialDetailsWhereInput | FinancialDetailsWhereInput[]
    ID?: IntFilter<"FinancialDetails"> | number
    CreditCardType?: StringNullableFilter<"FinancialDetails"> | string | null
    CreditCardNumber?: StringNullableFilter<"FinancialDetails"> | string | null
    CreditCardExpiry?: StringNullableFilter<"FinancialDetails"> | string | null
    CreditCardCVV2?: IntNullableFilter<"FinancialDetails"> | number | null
    CountryID?: IntFilter<"FinancialDetails"> | number
    Country?: XOR<CountriesRelationFilter, CountriesWhereInput>
  }

  export type FinancialDetailsOrderByWithRelationInput = {
    ID?: SortOrder
    CreditCardType?: SortOrderInput | SortOrder
    CreditCardNumber?: SortOrderInput | SortOrder
    CreditCardExpiry?: SortOrderInput | SortOrder
    CreditCardCVV2?: SortOrderInput | SortOrder
    CountryID?: SortOrder
    Country?: CountriesOrderByWithRelationInput
  }

  export type FinancialDetailsWhereUniqueInput = Prisma.AtLeast<{
    ID?: number
    CreditCardNumber?: string
    AND?: FinancialDetailsWhereInput | FinancialDetailsWhereInput[]
    OR?: FinancialDetailsWhereInput[]
    NOT?: FinancialDetailsWhereInput | FinancialDetailsWhereInput[]
    CreditCardType?: StringNullableFilter<"FinancialDetails"> | string | null
    CreditCardExpiry?: StringNullableFilter<"FinancialDetails"> | string | null
    CreditCardCVV2?: IntNullableFilter<"FinancialDetails"> | number | null
    CountryID?: IntFilter<"FinancialDetails"> | number
    Country?: XOR<CountriesRelationFilter, CountriesWhereInput>
  }, "ID" | "CreditCardNumber">

  export type FinancialDetailsOrderByWithAggregationInput = {
    ID?: SortOrder
    CreditCardType?: SortOrderInput | SortOrder
    CreditCardNumber?: SortOrderInput | SortOrder
    CreditCardExpiry?: SortOrderInput | SortOrder
    CreditCardCVV2?: SortOrderInput | SortOrder
    CountryID?: SortOrder
    _count?: FinancialDetailsCountOrderByAggregateInput
    _avg?: FinancialDetailsAvgOrderByAggregateInput
    _max?: FinancialDetailsMaxOrderByAggregateInput
    _min?: FinancialDetailsMinOrderByAggregateInput
    _sum?: FinancialDetailsSumOrderByAggregateInput
  }

  export type FinancialDetailsScalarWhereWithAggregatesInput = {
    AND?: FinancialDetailsScalarWhereWithAggregatesInput | FinancialDetailsScalarWhereWithAggregatesInput[]
    OR?: FinancialDetailsScalarWhereWithAggregatesInput[]
    NOT?: FinancialDetailsScalarWhereWithAggregatesInput | FinancialDetailsScalarWhereWithAggregatesInput[]
    ID?: IntWithAggregatesFilter<"FinancialDetails"> | number
    CreditCardType?: StringNullableWithAggregatesFilter<"FinancialDetails"> | string | null
    CreditCardNumber?: StringNullableWithAggregatesFilter<"FinancialDetails"> | string | null
    CreditCardExpiry?: StringNullableWithAggregatesFilter<"FinancialDetails"> | string | null
    CreditCardCVV2?: IntNullableWithAggregatesFilter<"FinancialDetails"> | number | null
    CountryID?: IntWithAggregatesFilter<"FinancialDetails"> | number
  }

  export type InternetDetailsWhereInput = {
    AND?: InternetDetailsWhereInput | InternetDetailsWhereInput[]
    OR?: InternetDetailsWhereInput[]
    NOT?: InternetDetailsWhereInput | InternetDetailsWhereInput[]
    ID?: IntFilter<"InternetDetails"> | number
    UserName?: StringNullableFilter<"InternetDetails"> | string | null
    Password?: StringNullableFilter<"InternetDetails"> | string | null
    IPv4Address?: StringNullableFilter<"InternetDetails"> | string | null
    IPv6Address?: StringNullableFilter<"InternetDetails"> | string | null
    UserAgent?: StringNullableFilter<"InternetDetails"> | string | null
    CountryID?: IntFilter<"InternetDetails"> | number
    Country?: XOR<CountriesRelationFilter, CountriesWhereInput>
  }

  export type InternetDetailsOrderByWithRelationInput = {
    ID?: SortOrder
    UserName?: SortOrderInput | SortOrder
    Password?: SortOrderInput | SortOrder
    IPv4Address?: SortOrderInput | SortOrder
    IPv6Address?: SortOrderInput | SortOrder
    UserAgent?: SortOrderInput | SortOrder
    CountryID?: SortOrder
    Country?: CountriesOrderByWithRelationInput
  }

  export type InternetDetailsWhereUniqueInput = Prisma.AtLeast<{
    ID?: number
    UserName?: string
    IPv4Address?: string
    IPv6Address?: string
    AND?: InternetDetailsWhereInput | InternetDetailsWhereInput[]
    OR?: InternetDetailsWhereInput[]
    NOT?: InternetDetailsWhereInput | InternetDetailsWhereInput[]
    Password?: StringNullableFilter<"InternetDetails"> | string | null
    UserAgent?: StringNullableFilter<"InternetDetails"> | string | null
    CountryID?: IntFilter<"InternetDetails"> | number
    Country?: XOR<CountriesRelationFilter, CountriesWhereInput>
  }, "ID" | "UserName" | "IPv4Address" | "IPv6Address">

  export type InternetDetailsOrderByWithAggregationInput = {
    ID?: SortOrder
    UserName?: SortOrderInput | SortOrder
    Password?: SortOrderInput | SortOrder
    IPv4Address?: SortOrderInput | SortOrder
    IPv6Address?: SortOrderInput | SortOrder
    UserAgent?: SortOrderInput | SortOrder
    CountryID?: SortOrder
    _count?: InternetDetailsCountOrderByAggregateInput
    _avg?: InternetDetailsAvgOrderByAggregateInput
    _max?: InternetDetailsMaxOrderByAggregateInput
    _min?: InternetDetailsMinOrderByAggregateInput
    _sum?: InternetDetailsSumOrderByAggregateInput
  }

  export type InternetDetailsScalarWhereWithAggregatesInput = {
    AND?: InternetDetailsScalarWhereWithAggregatesInput | InternetDetailsScalarWhereWithAggregatesInput[]
    OR?: InternetDetailsScalarWhereWithAggregatesInput[]
    NOT?: InternetDetailsScalarWhereWithAggregatesInput | InternetDetailsScalarWhereWithAggregatesInput[]
    ID?: IntWithAggregatesFilter<"InternetDetails"> | number
    UserName?: StringNullableWithAggregatesFilter<"InternetDetails"> | string | null
    Password?: StringNullableWithAggregatesFilter<"InternetDetails"> | string | null
    IPv4Address?: StringNullableWithAggregatesFilter<"InternetDetails"> | string | null
    IPv6Address?: StringNullableWithAggregatesFilter<"InternetDetails"> | string | null
    UserAgent?: StringNullableWithAggregatesFilter<"InternetDetails"> | string | null
    CountryID?: IntWithAggregatesFilter<"InternetDetails"> | number
  }

  export type EducationDetailsWhereInput = {
    AND?: EducationDetailsWhereInput | EducationDetailsWhereInput[]
    OR?: EducationDetailsWhereInput[]
    NOT?: EducationDetailsWhereInput | EducationDetailsWhereInput[]
    ID?: IntFilter<"EducationDetails"> | number
    Qualification?: StringNullableFilter<"EducationDetails"> | string | null
    Institution?: StringNullableFilter<"EducationDetails"> | string | null
    CountryID?: IntFilter<"EducationDetails"> | number
    Country?: XOR<CountriesRelationFilter, CountriesWhereInput>
  }

  export type EducationDetailsOrderByWithRelationInput = {
    ID?: SortOrder
    Qualification?: SortOrderInput | SortOrder
    Institution?: SortOrderInput | SortOrder
    CountryID?: SortOrder
    Country?: CountriesOrderByWithRelationInput
  }

  export type EducationDetailsWhereUniqueInput = Prisma.AtLeast<{
    ID?: number
    AND?: EducationDetailsWhereInput | EducationDetailsWhereInput[]
    OR?: EducationDetailsWhereInput[]
    NOT?: EducationDetailsWhereInput | EducationDetailsWhereInput[]
    Qualification?: StringNullableFilter<"EducationDetails"> | string | null
    Institution?: StringNullableFilter<"EducationDetails"> | string | null
    CountryID?: IntFilter<"EducationDetails"> | number
    Country?: XOR<CountriesRelationFilter, CountriesWhereInput>
  }, "ID">

  export type EducationDetailsOrderByWithAggregationInput = {
    ID?: SortOrder
    Qualification?: SortOrderInput | SortOrder
    Institution?: SortOrderInput | SortOrder
    CountryID?: SortOrder
    _count?: EducationDetailsCountOrderByAggregateInput
    _avg?: EducationDetailsAvgOrderByAggregateInput
    _max?: EducationDetailsMaxOrderByAggregateInput
    _min?: EducationDetailsMinOrderByAggregateInput
    _sum?: EducationDetailsSumOrderByAggregateInput
  }

  export type EducationDetailsScalarWhereWithAggregatesInput = {
    AND?: EducationDetailsScalarWhereWithAggregatesInput | EducationDetailsScalarWhereWithAggregatesInput[]
    OR?: EducationDetailsScalarWhereWithAggregatesInput[]
    NOT?: EducationDetailsScalarWhereWithAggregatesInput | EducationDetailsScalarWhereWithAggregatesInput[]
    ID?: IntWithAggregatesFilter<"EducationDetails"> | number
    Qualification?: StringNullableWithAggregatesFilter<"EducationDetails"> | string | null
    Institution?: StringNullableWithAggregatesFilter<"EducationDetails"> | string | null
    CountryID?: IntWithAggregatesFilter<"EducationDetails"> | number
  }

  export type EmploymentDetailsWhereInput = {
    AND?: EmploymentDetailsWhereInput | EmploymentDetailsWhereInput[]
    OR?: EmploymentDetailsWhereInput[]
    NOT?: EmploymentDetailsWhereInput | EmploymentDetailsWhereInput[]
    ID?: IntFilter<"EmploymentDetails"> | number
    CompanyName?: StringNullableFilter<"EmploymentDetails"> | string | null
    Salary?: StringNullableFilter<"EmploymentDetails"> | string | null
    CompanyAddress?: StringNullableFilter<"EmploymentDetails"> | string | null
    JobTitle?: StringNullableFilter<"EmploymentDetails"> | string | null
    CompanyPhone?: StringNullableFilter<"EmploymentDetails"> | string | null
    CompanyEmail?: StringNullableFilter<"EmploymentDetails"> | string | null
    CountryID?: IntFilter<"EmploymentDetails"> | number
    Country?: XOR<CountriesRelationFilter, CountriesWhereInput>
  }

  export type EmploymentDetailsOrderByWithRelationInput = {
    ID?: SortOrder
    CompanyName?: SortOrderInput | SortOrder
    Salary?: SortOrderInput | SortOrder
    CompanyAddress?: SortOrderInput | SortOrder
    JobTitle?: SortOrderInput | SortOrder
    CompanyPhone?: SortOrderInput | SortOrder
    CompanyEmail?: SortOrderInput | SortOrder
    CountryID?: SortOrder
    Country?: CountriesOrderByWithRelationInput
  }

  export type EmploymentDetailsWhereUniqueInput = Prisma.AtLeast<{
    ID?: number
    CompanyEmail?: string
    AND?: EmploymentDetailsWhereInput | EmploymentDetailsWhereInput[]
    OR?: EmploymentDetailsWhereInput[]
    NOT?: EmploymentDetailsWhereInput | EmploymentDetailsWhereInput[]
    CompanyName?: StringNullableFilter<"EmploymentDetails"> | string | null
    Salary?: StringNullableFilter<"EmploymentDetails"> | string | null
    CompanyAddress?: StringNullableFilter<"EmploymentDetails"> | string | null
    JobTitle?: StringNullableFilter<"EmploymentDetails"> | string | null
    CompanyPhone?: StringNullableFilter<"EmploymentDetails"> | string | null
    CountryID?: IntFilter<"EmploymentDetails"> | number
    Country?: XOR<CountriesRelationFilter, CountriesWhereInput>
  }, "ID" | "CompanyEmail">

  export type EmploymentDetailsOrderByWithAggregationInput = {
    ID?: SortOrder
    CompanyName?: SortOrderInput | SortOrder
    Salary?: SortOrderInput | SortOrder
    CompanyAddress?: SortOrderInput | SortOrder
    JobTitle?: SortOrderInput | SortOrder
    CompanyPhone?: SortOrderInput | SortOrder
    CompanyEmail?: SortOrderInput | SortOrder
    CountryID?: SortOrder
    _count?: EmploymentDetailsCountOrderByAggregateInput
    _avg?: EmploymentDetailsAvgOrderByAggregateInput
    _max?: EmploymentDetailsMaxOrderByAggregateInput
    _min?: EmploymentDetailsMinOrderByAggregateInput
    _sum?: EmploymentDetailsSumOrderByAggregateInput
  }

  export type EmploymentDetailsScalarWhereWithAggregatesInput = {
    AND?: EmploymentDetailsScalarWhereWithAggregatesInput | EmploymentDetailsScalarWhereWithAggregatesInput[]
    OR?: EmploymentDetailsScalarWhereWithAggregatesInput[]
    NOT?: EmploymentDetailsScalarWhereWithAggregatesInput | EmploymentDetailsScalarWhereWithAggregatesInput[]
    ID?: IntWithAggregatesFilter<"EmploymentDetails"> | number
    CompanyName?: StringNullableWithAggregatesFilter<"EmploymentDetails"> | string | null
    Salary?: StringNullableWithAggregatesFilter<"EmploymentDetails"> | string | null
    CompanyAddress?: StringNullableWithAggregatesFilter<"EmploymentDetails"> | string | null
    JobTitle?: StringNullableWithAggregatesFilter<"EmploymentDetails"> | string | null
    CompanyPhone?: StringNullableWithAggregatesFilter<"EmploymentDetails"> | string | null
    CompanyEmail?: StringNullableWithAggregatesFilter<"EmploymentDetails"> | string | null
    CountryID?: IntWithAggregatesFilter<"EmploymentDetails"> | number
  }

  export type VehicleDetailsWhereInput = {
    AND?: VehicleDetailsWhereInput | VehicleDetailsWhereInput[]
    OR?: VehicleDetailsWhereInput[]
    NOT?: VehicleDetailsWhereInput | VehicleDetailsWhereInput[]
    ID?: IntFilter<"VehicleDetails"> | number
    VehicleName?: StringNullableFilter<"VehicleDetails"> | string | null
    LicensePlate?: StringNullableFilter<"VehicleDetails"> | string | null
    VIN?: StringNullableFilter<"VehicleDetails"> | string | null
    Color?: StringNullableFilter<"VehicleDetails"> | string | null
    CountryID?: IntFilter<"VehicleDetails"> | number
    Country?: XOR<CountriesRelationFilter, CountriesWhereInput>
  }

  export type VehicleDetailsOrderByWithRelationInput = {
    ID?: SortOrder
    VehicleName?: SortOrderInput | SortOrder
    LicensePlate?: SortOrderInput | SortOrder
    VIN?: SortOrderInput | SortOrder
    Color?: SortOrderInput | SortOrder
    CountryID?: SortOrder
    Country?: CountriesOrderByWithRelationInput
  }

  export type VehicleDetailsWhereUniqueInput = Prisma.AtLeast<{
    ID?: number
    LicensePlate?: string
    VIN?: string
    AND?: VehicleDetailsWhereInput | VehicleDetailsWhereInput[]
    OR?: VehicleDetailsWhereInput[]
    NOT?: VehicleDetailsWhereInput | VehicleDetailsWhereInput[]
    VehicleName?: StringNullableFilter<"VehicleDetails"> | string | null
    Color?: StringNullableFilter<"VehicleDetails"> | string | null
    CountryID?: IntFilter<"VehicleDetails"> | number
    Country?: XOR<CountriesRelationFilter, CountriesWhereInput>
  }, "ID" | "LicensePlate" | "VIN">

  export type VehicleDetailsOrderByWithAggregationInput = {
    ID?: SortOrder
    VehicleName?: SortOrderInput | SortOrder
    LicensePlate?: SortOrderInput | SortOrder
    VIN?: SortOrderInput | SortOrder
    Color?: SortOrderInput | SortOrder
    CountryID?: SortOrder
    _count?: VehicleDetailsCountOrderByAggregateInput
    _avg?: VehicleDetailsAvgOrderByAggregateInput
    _max?: VehicleDetailsMaxOrderByAggregateInput
    _min?: VehicleDetailsMinOrderByAggregateInput
    _sum?: VehicleDetailsSumOrderByAggregateInput
  }

  export type VehicleDetailsScalarWhereWithAggregatesInput = {
    AND?: VehicleDetailsScalarWhereWithAggregatesInput | VehicleDetailsScalarWhereWithAggregatesInput[]
    OR?: VehicleDetailsScalarWhereWithAggregatesInput[]
    NOT?: VehicleDetailsScalarWhereWithAggregatesInput | VehicleDetailsScalarWhereWithAggregatesInput[]
    ID?: IntWithAggregatesFilter<"VehicleDetails"> | number
    VehicleName?: StringNullableWithAggregatesFilter<"VehicleDetails"> | string | null
    LicensePlate?: StringNullableWithAggregatesFilter<"VehicleDetails"> | string | null
    VIN?: StringNullableWithAggregatesFilter<"VehicleDetails"> | string | null
    Color?: StringNullableWithAggregatesFilter<"VehicleDetails"> | string | null
    CountryID?: IntWithAggregatesFilter<"VehicleDetails"> | number
  }

  export type CountriesCreateInput = {
    CountryName: string
    PersonalDetails?: PersonalDetailsCreateNestedManyWithoutCountryInput
    FinancialDetails?: FinancialDetailsCreateNestedManyWithoutCountryInput
    InternetDetails?: InternetDetailsCreateNestedManyWithoutCountryInput
    EducationDetails?: EducationDetailsCreateNestedManyWithoutCountryInput
    EmploymentDetails?: EmploymentDetailsCreateNestedManyWithoutCountryInput
    VehicleDetails?: VehicleDetailsCreateNestedManyWithoutCountryInput
  }

  export type CountriesUncheckedCreateInput = {
    CountryID?: number
    CountryName: string
    PersonalDetails?: PersonalDetailsUncheckedCreateNestedManyWithoutCountryInput
    FinancialDetails?: FinancialDetailsUncheckedCreateNestedManyWithoutCountryInput
    InternetDetails?: InternetDetailsUncheckedCreateNestedManyWithoutCountryInput
    EducationDetails?: EducationDetailsUncheckedCreateNestedManyWithoutCountryInput
    EmploymentDetails?: EmploymentDetailsUncheckedCreateNestedManyWithoutCountryInput
    VehicleDetails?: VehicleDetailsUncheckedCreateNestedManyWithoutCountryInput
  }

  export type CountriesUpdateInput = {
    CountryName?: StringFieldUpdateOperationsInput | string
    PersonalDetails?: PersonalDetailsUpdateManyWithoutCountryNestedInput
    FinancialDetails?: FinancialDetailsUpdateManyWithoutCountryNestedInput
    InternetDetails?: InternetDetailsUpdateManyWithoutCountryNestedInput
    EducationDetails?: EducationDetailsUpdateManyWithoutCountryNestedInput
    EmploymentDetails?: EmploymentDetailsUpdateManyWithoutCountryNestedInput
    VehicleDetails?: VehicleDetailsUpdateManyWithoutCountryNestedInput
  }

  export type CountriesUncheckedUpdateInput = {
    CountryID?: IntFieldUpdateOperationsInput | number
    CountryName?: StringFieldUpdateOperationsInput | string
    PersonalDetails?: PersonalDetailsUncheckedUpdateManyWithoutCountryNestedInput
    FinancialDetails?: FinancialDetailsUncheckedUpdateManyWithoutCountryNestedInput
    InternetDetails?: InternetDetailsUncheckedUpdateManyWithoutCountryNestedInput
    EducationDetails?: EducationDetailsUncheckedUpdateManyWithoutCountryNestedInput
    EmploymentDetails?: EmploymentDetailsUncheckedUpdateManyWithoutCountryNestedInput
    VehicleDetails?: VehicleDetailsUncheckedUpdateManyWithoutCountryNestedInput
  }

  export type CountriesCreateManyInput = {
    CountryID?: number
    CountryName: string
  }

  export type CountriesUpdateManyMutationInput = {
    CountryName?: StringFieldUpdateOperationsInput | string
  }

  export type CountriesUncheckedUpdateManyInput = {
    CountryID?: IntFieldUpdateOperationsInput | number
    CountryName?: StringFieldUpdateOperationsInput | string
  }

  export type PersonalDetailsCreateInput = {
    Name?: string | null
    Address?: string | null
    Postcode?: string | null
    City?: string | null
    DateOfBirth?: Date | string | null
    Gender?: string | null
    Phone?: string | null
    MothersMaidenName?: string | null
    Email?: string | null
    Ethnicity?: string | null
    ZodiacSign?: string | null
    Age?: number | null
    Height?: number | null
    Weight?: number | null
    EyeColor?: string | null
    HairColor?: string | null
    Country: CountriesCreateNestedOneWithoutPersonalDetailsInput
  }

  export type PersonalDetailsUncheckedCreateInput = {
    ID?: number
    Name?: string | null
    Address?: string | null
    Postcode?: string | null
    City?: string | null
    DateOfBirth?: Date | string | null
    Gender?: string | null
    Phone?: string | null
    MothersMaidenName?: string | null
    Email?: string | null
    Ethnicity?: string | null
    ZodiacSign?: string | null
    Age?: number | null
    Height?: number | null
    Weight?: number | null
    EyeColor?: string | null
    HairColor?: string | null
    CountryID: number
  }

  export type PersonalDetailsUpdateInput = {
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    Postcode?: NullableStringFieldUpdateOperationsInput | string | null
    City?: NullableStringFieldUpdateOperationsInput | string | null
    DateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Gender?: NullableStringFieldUpdateOperationsInput | string | null
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    MothersMaidenName?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Ethnicity?: NullableStringFieldUpdateOperationsInput | string | null
    ZodiacSign?: NullableStringFieldUpdateOperationsInput | string | null
    Age?: NullableIntFieldUpdateOperationsInput | number | null
    Height?: NullableFloatFieldUpdateOperationsInput | number | null
    Weight?: NullableFloatFieldUpdateOperationsInput | number | null
    EyeColor?: NullableStringFieldUpdateOperationsInput | string | null
    HairColor?: NullableStringFieldUpdateOperationsInput | string | null
    Country?: CountriesUpdateOneRequiredWithoutPersonalDetailsNestedInput
  }

  export type PersonalDetailsUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    Postcode?: NullableStringFieldUpdateOperationsInput | string | null
    City?: NullableStringFieldUpdateOperationsInput | string | null
    DateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Gender?: NullableStringFieldUpdateOperationsInput | string | null
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    MothersMaidenName?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Ethnicity?: NullableStringFieldUpdateOperationsInput | string | null
    ZodiacSign?: NullableStringFieldUpdateOperationsInput | string | null
    Age?: NullableIntFieldUpdateOperationsInput | number | null
    Height?: NullableFloatFieldUpdateOperationsInput | number | null
    Weight?: NullableFloatFieldUpdateOperationsInput | number | null
    EyeColor?: NullableStringFieldUpdateOperationsInput | string | null
    HairColor?: NullableStringFieldUpdateOperationsInput | string | null
    CountryID?: IntFieldUpdateOperationsInput | number
  }

  export type PersonalDetailsCreateManyInput = {
    ID?: number
    Name?: string | null
    Address?: string | null
    Postcode?: string | null
    City?: string | null
    DateOfBirth?: Date | string | null
    Gender?: string | null
    Phone?: string | null
    MothersMaidenName?: string | null
    Email?: string | null
    Ethnicity?: string | null
    ZodiacSign?: string | null
    Age?: number | null
    Height?: number | null
    Weight?: number | null
    EyeColor?: string | null
    HairColor?: string | null
    CountryID: number
  }

  export type PersonalDetailsUpdateManyMutationInput = {
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    Postcode?: NullableStringFieldUpdateOperationsInput | string | null
    City?: NullableStringFieldUpdateOperationsInput | string | null
    DateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Gender?: NullableStringFieldUpdateOperationsInput | string | null
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    MothersMaidenName?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Ethnicity?: NullableStringFieldUpdateOperationsInput | string | null
    ZodiacSign?: NullableStringFieldUpdateOperationsInput | string | null
    Age?: NullableIntFieldUpdateOperationsInput | number | null
    Height?: NullableFloatFieldUpdateOperationsInput | number | null
    Weight?: NullableFloatFieldUpdateOperationsInput | number | null
    EyeColor?: NullableStringFieldUpdateOperationsInput | string | null
    HairColor?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PersonalDetailsUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    Postcode?: NullableStringFieldUpdateOperationsInput | string | null
    City?: NullableStringFieldUpdateOperationsInput | string | null
    DateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Gender?: NullableStringFieldUpdateOperationsInput | string | null
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    MothersMaidenName?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Ethnicity?: NullableStringFieldUpdateOperationsInput | string | null
    ZodiacSign?: NullableStringFieldUpdateOperationsInput | string | null
    Age?: NullableIntFieldUpdateOperationsInput | number | null
    Height?: NullableFloatFieldUpdateOperationsInput | number | null
    Weight?: NullableFloatFieldUpdateOperationsInput | number | null
    EyeColor?: NullableStringFieldUpdateOperationsInput | string | null
    HairColor?: NullableStringFieldUpdateOperationsInput | string | null
    CountryID?: IntFieldUpdateOperationsInput | number
  }

  export type FinancialDetailsCreateInput = {
    CreditCardType?: string | null
    CreditCardNumber?: string | null
    CreditCardExpiry?: string | null
    CreditCardCVV2?: number | null
    Country: CountriesCreateNestedOneWithoutFinancialDetailsInput
  }

  export type FinancialDetailsUncheckedCreateInput = {
    ID?: number
    CreditCardType?: string | null
    CreditCardNumber?: string | null
    CreditCardExpiry?: string | null
    CreditCardCVV2?: number | null
    CountryID: number
  }

  export type FinancialDetailsUpdateInput = {
    CreditCardType?: NullableStringFieldUpdateOperationsInput | string | null
    CreditCardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    CreditCardExpiry?: NullableStringFieldUpdateOperationsInput | string | null
    CreditCardCVV2?: NullableIntFieldUpdateOperationsInput | number | null
    Country?: CountriesUpdateOneRequiredWithoutFinancialDetailsNestedInput
  }

  export type FinancialDetailsUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    CreditCardType?: NullableStringFieldUpdateOperationsInput | string | null
    CreditCardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    CreditCardExpiry?: NullableStringFieldUpdateOperationsInput | string | null
    CreditCardCVV2?: NullableIntFieldUpdateOperationsInput | number | null
    CountryID?: IntFieldUpdateOperationsInput | number
  }

  export type FinancialDetailsCreateManyInput = {
    ID?: number
    CreditCardType?: string | null
    CreditCardNumber?: string | null
    CreditCardExpiry?: string | null
    CreditCardCVV2?: number | null
    CountryID: number
  }

  export type FinancialDetailsUpdateManyMutationInput = {
    CreditCardType?: NullableStringFieldUpdateOperationsInput | string | null
    CreditCardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    CreditCardExpiry?: NullableStringFieldUpdateOperationsInput | string | null
    CreditCardCVV2?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type FinancialDetailsUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    CreditCardType?: NullableStringFieldUpdateOperationsInput | string | null
    CreditCardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    CreditCardExpiry?: NullableStringFieldUpdateOperationsInput | string | null
    CreditCardCVV2?: NullableIntFieldUpdateOperationsInput | number | null
    CountryID?: IntFieldUpdateOperationsInput | number
  }

  export type InternetDetailsCreateInput = {
    UserName?: string | null
    Password?: string | null
    IPv4Address?: string | null
    IPv6Address?: string | null
    UserAgent?: string | null
    Country: CountriesCreateNestedOneWithoutInternetDetailsInput
  }

  export type InternetDetailsUncheckedCreateInput = {
    ID?: number
    UserName?: string | null
    Password?: string | null
    IPv4Address?: string | null
    IPv6Address?: string | null
    UserAgent?: string | null
    CountryID: number
  }

  export type InternetDetailsUpdateInput = {
    UserName?: NullableStringFieldUpdateOperationsInput | string | null
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    IPv4Address?: NullableStringFieldUpdateOperationsInput | string | null
    IPv6Address?: NullableStringFieldUpdateOperationsInput | string | null
    UserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    Country?: CountriesUpdateOneRequiredWithoutInternetDetailsNestedInput
  }

  export type InternetDetailsUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    UserName?: NullableStringFieldUpdateOperationsInput | string | null
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    IPv4Address?: NullableStringFieldUpdateOperationsInput | string | null
    IPv6Address?: NullableStringFieldUpdateOperationsInput | string | null
    UserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    CountryID?: IntFieldUpdateOperationsInput | number
  }

  export type InternetDetailsCreateManyInput = {
    ID?: number
    UserName?: string | null
    Password?: string | null
    IPv4Address?: string | null
    IPv6Address?: string | null
    UserAgent?: string | null
    CountryID: number
  }

  export type InternetDetailsUpdateManyMutationInput = {
    UserName?: NullableStringFieldUpdateOperationsInput | string | null
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    IPv4Address?: NullableStringFieldUpdateOperationsInput | string | null
    IPv6Address?: NullableStringFieldUpdateOperationsInput | string | null
    UserAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InternetDetailsUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    UserName?: NullableStringFieldUpdateOperationsInput | string | null
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    IPv4Address?: NullableStringFieldUpdateOperationsInput | string | null
    IPv6Address?: NullableStringFieldUpdateOperationsInput | string | null
    UserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    CountryID?: IntFieldUpdateOperationsInput | number
  }

  export type EducationDetailsCreateInput = {
    Qualification?: string | null
    Institution?: string | null
    Country: CountriesCreateNestedOneWithoutEducationDetailsInput
  }

  export type EducationDetailsUncheckedCreateInput = {
    ID?: number
    Qualification?: string | null
    Institution?: string | null
    CountryID: number
  }

  export type EducationDetailsUpdateInput = {
    Qualification?: NullableStringFieldUpdateOperationsInput | string | null
    Institution?: NullableStringFieldUpdateOperationsInput | string | null
    Country?: CountriesUpdateOneRequiredWithoutEducationDetailsNestedInput
  }

  export type EducationDetailsUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Qualification?: NullableStringFieldUpdateOperationsInput | string | null
    Institution?: NullableStringFieldUpdateOperationsInput | string | null
    CountryID?: IntFieldUpdateOperationsInput | number
  }

  export type EducationDetailsCreateManyInput = {
    ID?: number
    Qualification?: string | null
    Institution?: string | null
    CountryID: number
  }

  export type EducationDetailsUpdateManyMutationInput = {
    Qualification?: NullableStringFieldUpdateOperationsInput | string | null
    Institution?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EducationDetailsUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Qualification?: NullableStringFieldUpdateOperationsInput | string | null
    Institution?: NullableStringFieldUpdateOperationsInput | string | null
    CountryID?: IntFieldUpdateOperationsInput | number
  }

  export type EmploymentDetailsCreateInput = {
    CompanyName?: string | null
    Salary?: string | null
    CompanyAddress?: string | null
    JobTitle?: string | null
    CompanyPhone?: string | null
    CompanyEmail?: string | null
    Country: CountriesCreateNestedOneWithoutEmploymentDetailsInput
  }

  export type EmploymentDetailsUncheckedCreateInput = {
    ID?: number
    CompanyName?: string | null
    Salary?: string | null
    CompanyAddress?: string | null
    JobTitle?: string | null
    CompanyPhone?: string | null
    CompanyEmail?: string | null
    CountryID: number
  }

  export type EmploymentDetailsUpdateInput = {
    CompanyName?: NullableStringFieldUpdateOperationsInput | string | null
    Salary?: NullableStringFieldUpdateOperationsInput | string | null
    CompanyAddress?: NullableStringFieldUpdateOperationsInput | string | null
    JobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    CompanyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    CompanyEmail?: NullableStringFieldUpdateOperationsInput | string | null
    Country?: CountriesUpdateOneRequiredWithoutEmploymentDetailsNestedInput
  }

  export type EmploymentDetailsUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    CompanyName?: NullableStringFieldUpdateOperationsInput | string | null
    Salary?: NullableStringFieldUpdateOperationsInput | string | null
    CompanyAddress?: NullableStringFieldUpdateOperationsInput | string | null
    JobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    CompanyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    CompanyEmail?: NullableStringFieldUpdateOperationsInput | string | null
    CountryID?: IntFieldUpdateOperationsInput | number
  }

  export type EmploymentDetailsCreateManyInput = {
    ID?: number
    CompanyName?: string | null
    Salary?: string | null
    CompanyAddress?: string | null
    JobTitle?: string | null
    CompanyPhone?: string | null
    CompanyEmail?: string | null
    CountryID: number
  }

  export type EmploymentDetailsUpdateManyMutationInput = {
    CompanyName?: NullableStringFieldUpdateOperationsInput | string | null
    Salary?: NullableStringFieldUpdateOperationsInput | string | null
    CompanyAddress?: NullableStringFieldUpdateOperationsInput | string | null
    JobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    CompanyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    CompanyEmail?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmploymentDetailsUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    CompanyName?: NullableStringFieldUpdateOperationsInput | string | null
    Salary?: NullableStringFieldUpdateOperationsInput | string | null
    CompanyAddress?: NullableStringFieldUpdateOperationsInput | string | null
    JobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    CompanyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    CompanyEmail?: NullableStringFieldUpdateOperationsInput | string | null
    CountryID?: IntFieldUpdateOperationsInput | number
  }

  export type VehicleDetailsCreateInput = {
    VehicleName?: string | null
    LicensePlate?: string | null
    VIN?: string | null
    Color?: string | null
    Country: CountriesCreateNestedOneWithoutVehicleDetailsInput
  }

  export type VehicleDetailsUncheckedCreateInput = {
    ID?: number
    VehicleName?: string | null
    LicensePlate?: string | null
    VIN?: string | null
    Color?: string | null
    CountryID: number
  }

  export type VehicleDetailsUpdateInput = {
    VehicleName?: NullableStringFieldUpdateOperationsInput | string | null
    LicensePlate?: NullableStringFieldUpdateOperationsInput | string | null
    VIN?: NullableStringFieldUpdateOperationsInput | string | null
    Color?: NullableStringFieldUpdateOperationsInput | string | null
    Country?: CountriesUpdateOneRequiredWithoutVehicleDetailsNestedInput
  }

  export type VehicleDetailsUncheckedUpdateInput = {
    ID?: IntFieldUpdateOperationsInput | number
    VehicleName?: NullableStringFieldUpdateOperationsInput | string | null
    LicensePlate?: NullableStringFieldUpdateOperationsInput | string | null
    VIN?: NullableStringFieldUpdateOperationsInput | string | null
    Color?: NullableStringFieldUpdateOperationsInput | string | null
    CountryID?: IntFieldUpdateOperationsInput | number
  }

  export type VehicleDetailsCreateManyInput = {
    ID?: number
    VehicleName?: string | null
    LicensePlate?: string | null
    VIN?: string | null
    Color?: string | null
    CountryID: number
  }

  export type VehicleDetailsUpdateManyMutationInput = {
    VehicleName?: NullableStringFieldUpdateOperationsInput | string | null
    LicensePlate?: NullableStringFieldUpdateOperationsInput | string | null
    VIN?: NullableStringFieldUpdateOperationsInput | string | null
    Color?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VehicleDetailsUncheckedUpdateManyInput = {
    ID?: IntFieldUpdateOperationsInput | number
    VehicleName?: NullableStringFieldUpdateOperationsInput | string | null
    LicensePlate?: NullableStringFieldUpdateOperationsInput | string | null
    VIN?: NullableStringFieldUpdateOperationsInput | string | null
    Color?: NullableStringFieldUpdateOperationsInput | string | null
    CountryID?: IntFieldUpdateOperationsInput | number
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type PersonalDetailsListRelationFilter = {
    every?: PersonalDetailsWhereInput
    some?: PersonalDetailsWhereInput
    none?: PersonalDetailsWhereInput
  }

  export type FinancialDetailsListRelationFilter = {
    every?: FinancialDetailsWhereInput
    some?: FinancialDetailsWhereInput
    none?: FinancialDetailsWhereInput
  }

  export type InternetDetailsListRelationFilter = {
    every?: InternetDetailsWhereInput
    some?: InternetDetailsWhereInput
    none?: InternetDetailsWhereInput
  }

  export type EducationDetailsListRelationFilter = {
    every?: EducationDetailsWhereInput
    some?: EducationDetailsWhereInput
    none?: EducationDetailsWhereInput
  }

  export type EmploymentDetailsListRelationFilter = {
    every?: EmploymentDetailsWhereInput
    some?: EmploymentDetailsWhereInput
    none?: EmploymentDetailsWhereInput
  }

  export type VehicleDetailsListRelationFilter = {
    every?: VehicleDetailsWhereInput
    some?: VehicleDetailsWhereInput
    none?: VehicleDetailsWhereInput
  }

  export type PersonalDetailsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FinancialDetailsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InternetDetailsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EducationDetailsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmploymentDetailsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VehicleDetailsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CountriesCountOrderByAggregateInput = {
    CountryID?: SortOrder
    CountryName?: SortOrder
  }

  export type CountriesAvgOrderByAggregateInput = {
    CountryID?: SortOrder
  }

  export type CountriesMaxOrderByAggregateInput = {
    CountryID?: SortOrder
    CountryName?: SortOrder
  }

  export type CountriesMinOrderByAggregateInput = {
    CountryID?: SortOrder
    CountryName?: SortOrder
  }

  export type CountriesSumOrderByAggregateInput = {
    CountryID?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type CountriesRelationFilter = {
    is?: CountriesWhereInput
    isNot?: CountriesWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type PersonalDetailsCountOrderByAggregateInput = {
    ID?: SortOrder
    Name?: SortOrder
    Address?: SortOrder
    Postcode?: SortOrder
    City?: SortOrder
    DateOfBirth?: SortOrder
    Gender?: SortOrder
    Phone?: SortOrder
    MothersMaidenName?: SortOrder
    Email?: SortOrder
    Ethnicity?: SortOrder
    ZodiacSign?: SortOrder
    Age?: SortOrder
    Height?: SortOrder
    Weight?: SortOrder
    EyeColor?: SortOrder
    HairColor?: SortOrder
    CountryID?: SortOrder
  }

  export type PersonalDetailsAvgOrderByAggregateInput = {
    ID?: SortOrder
    Age?: SortOrder
    Height?: SortOrder
    Weight?: SortOrder
    CountryID?: SortOrder
  }

  export type PersonalDetailsMaxOrderByAggregateInput = {
    ID?: SortOrder
    Name?: SortOrder
    Address?: SortOrder
    Postcode?: SortOrder
    City?: SortOrder
    DateOfBirth?: SortOrder
    Gender?: SortOrder
    Phone?: SortOrder
    MothersMaidenName?: SortOrder
    Email?: SortOrder
    Ethnicity?: SortOrder
    ZodiacSign?: SortOrder
    Age?: SortOrder
    Height?: SortOrder
    Weight?: SortOrder
    EyeColor?: SortOrder
    HairColor?: SortOrder
    CountryID?: SortOrder
  }

  export type PersonalDetailsMinOrderByAggregateInput = {
    ID?: SortOrder
    Name?: SortOrder
    Address?: SortOrder
    Postcode?: SortOrder
    City?: SortOrder
    DateOfBirth?: SortOrder
    Gender?: SortOrder
    Phone?: SortOrder
    MothersMaidenName?: SortOrder
    Email?: SortOrder
    Ethnicity?: SortOrder
    ZodiacSign?: SortOrder
    Age?: SortOrder
    Height?: SortOrder
    Weight?: SortOrder
    EyeColor?: SortOrder
    HairColor?: SortOrder
    CountryID?: SortOrder
  }

  export type PersonalDetailsSumOrderByAggregateInput = {
    ID?: SortOrder
    Age?: SortOrder
    Height?: SortOrder
    Weight?: SortOrder
    CountryID?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type FinancialDetailsCountOrderByAggregateInput = {
    ID?: SortOrder
    CreditCardType?: SortOrder
    CreditCardNumber?: SortOrder
    CreditCardExpiry?: SortOrder
    CreditCardCVV2?: SortOrder
    CountryID?: SortOrder
  }

  export type FinancialDetailsAvgOrderByAggregateInput = {
    ID?: SortOrder
    CreditCardCVV2?: SortOrder
    CountryID?: SortOrder
  }

  export type FinancialDetailsMaxOrderByAggregateInput = {
    ID?: SortOrder
    CreditCardType?: SortOrder
    CreditCardNumber?: SortOrder
    CreditCardExpiry?: SortOrder
    CreditCardCVV2?: SortOrder
    CountryID?: SortOrder
  }

  export type FinancialDetailsMinOrderByAggregateInput = {
    ID?: SortOrder
    CreditCardType?: SortOrder
    CreditCardNumber?: SortOrder
    CreditCardExpiry?: SortOrder
    CreditCardCVV2?: SortOrder
    CountryID?: SortOrder
  }

  export type FinancialDetailsSumOrderByAggregateInput = {
    ID?: SortOrder
    CreditCardCVV2?: SortOrder
    CountryID?: SortOrder
  }

  export type InternetDetailsCountOrderByAggregateInput = {
    ID?: SortOrder
    UserName?: SortOrder
    Password?: SortOrder
    IPv4Address?: SortOrder
    IPv6Address?: SortOrder
    UserAgent?: SortOrder
    CountryID?: SortOrder
  }

  export type InternetDetailsAvgOrderByAggregateInput = {
    ID?: SortOrder
    CountryID?: SortOrder
  }

  export type InternetDetailsMaxOrderByAggregateInput = {
    ID?: SortOrder
    UserName?: SortOrder
    Password?: SortOrder
    IPv4Address?: SortOrder
    IPv6Address?: SortOrder
    UserAgent?: SortOrder
    CountryID?: SortOrder
  }

  export type InternetDetailsMinOrderByAggregateInput = {
    ID?: SortOrder
    UserName?: SortOrder
    Password?: SortOrder
    IPv4Address?: SortOrder
    IPv6Address?: SortOrder
    UserAgent?: SortOrder
    CountryID?: SortOrder
  }

  export type InternetDetailsSumOrderByAggregateInput = {
    ID?: SortOrder
    CountryID?: SortOrder
  }

  export type EducationDetailsCountOrderByAggregateInput = {
    ID?: SortOrder
    Qualification?: SortOrder
    Institution?: SortOrder
    CountryID?: SortOrder
  }

  export type EducationDetailsAvgOrderByAggregateInput = {
    ID?: SortOrder
    CountryID?: SortOrder
  }

  export type EducationDetailsMaxOrderByAggregateInput = {
    ID?: SortOrder
    Qualification?: SortOrder
    Institution?: SortOrder
    CountryID?: SortOrder
  }

  export type EducationDetailsMinOrderByAggregateInput = {
    ID?: SortOrder
    Qualification?: SortOrder
    Institution?: SortOrder
    CountryID?: SortOrder
  }

  export type EducationDetailsSumOrderByAggregateInput = {
    ID?: SortOrder
    CountryID?: SortOrder
  }

  export type EmploymentDetailsCountOrderByAggregateInput = {
    ID?: SortOrder
    CompanyName?: SortOrder
    Salary?: SortOrder
    CompanyAddress?: SortOrder
    JobTitle?: SortOrder
    CompanyPhone?: SortOrder
    CompanyEmail?: SortOrder
    CountryID?: SortOrder
  }

  export type EmploymentDetailsAvgOrderByAggregateInput = {
    ID?: SortOrder
    CountryID?: SortOrder
  }

  export type EmploymentDetailsMaxOrderByAggregateInput = {
    ID?: SortOrder
    CompanyName?: SortOrder
    Salary?: SortOrder
    CompanyAddress?: SortOrder
    JobTitle?: SortOrder
    CompanyPhone?: SortOrder
    CompanyEmail?: SortOrder
    CountryID?: SortOrder
  }

  export type EmploymentDetailsMinOrderByAggregateInput = {
    ID?: SortOrder
    CompanyName?: SortOrder
    Salary?: SortOrder
    CompanyAddress?: SortOrder
    JobTitle?: SortOrder
    CompanyPhone?: SortOrder
    CompanyEmail?: SortOrder
    CountryID?: SortOrder
  }

  export type EmploymentDetailsSumOrderByAggregateInput = {
    ID?: SortOrder
    CountryID?: SortOrder
  }

  export type VehicleDetailsCountOrderByAggregateInput = {
    ID?: SortOrder
    VehicleName?: SortOrder
    LicensePlate?: SortOrder
    VIN?: SortOrder
    Color?: SortOrder
    CountryID?: SortOrder
  }

  export type VehicleDetailsAvgOrderByAggregateInput = {
    ID?: SortOrder
    CountryID?: SortOrder
  }

  export type VehicleDetailsMaxOrderByAggregateInput = {
    ID?: SortOrder
    VehicleName?: SortOrder
    LicensePlate?: SortOrder
    VIN?: SortOrder
    Color?: SortOrder
    CountryID?: SortOrder
  }

  export type VehicleDetailsMinOrderByAggregateInput = {
    ID?: SortOrder
    VehicleName?: SortOrder
    LicensePlate?: SortOrder
    VIN?: SortOrder
    Color?: SortOrder
    CountryID?: SortOrder
  }

  export type VehicleDetailsSumOrderByAggregateInput = {
    ID?: SortOrder
    CountryID?: SortOrder
  }

  export type PersonalDetailsCreateNestedManyWithoutCountryInput = {
    create?: XOR<PersonalDetailsCreateWithoutCountryInput, PersonalDetailsUncheckedCreateWithoutCountryInput> | PersonalDetailsCreateWithoutCountryInput[] | PersonalDetailsUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: PersonalDetailsCreateOrConnectWithoutCountryInput | PersonalDetailsCreateOrConnectWithoutCountryInput[]
    createMany?: PersonalDetailsCreateManyCountryInputEnvelope
    connect?: PersonalDetailsWhereUniqueInput | PersonalDetailsWhereUniqueInput[]
  }

  export type FinancialDetailsCreateNestedManyWithoutCountryInput = {
    create?: XOR<FinancialDetailsCreateWithoutCountryInput, FinancialDetailsUncheckedCreateWithoutCountryInput> | FinancialDetailsCreateWithoutCountryInput[] | FinancialDetailsUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: FinancialDetailsCreateOrConnectWithoutCountryInput | FinancialDetailsCreateOrConnectWithoutCountryInput[]
    createMany?: FinancialDetailsCreateManyCountryInputEnvelope
    connect?: FinancialDetailsWhereUniqueInput | FinancialDetailsWhereUniqueInput[]
  }

  export type InternetDetailsCreateNestedManyWithoutCountryInput = {
    create?: XOR<InternetDetailsCreateWithoutCountryInput, InternetDetailsUncheckedCreateWithoutCountryInput> | InternetDetailsCreateWithoutCountryInput[] | InternetDetailsUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: InternetDetailsCreateOrConnectWithoutCountryInput | InternetDetailsCreateOrConnectWithoutCountryInput[]
    createMany?: InternetDetailsCreateManyCountryInputEnvelope
    connect?: InternetDetailsWhereUniqueInput | InternetDetailsWhereUniqueInput[]
  }

  export type EducationDetailsCreateNestedManyWithoutCountryInput = {
    create?: XOR<EducationDetailsCreateWithoutCountryInput, EducationDetailsUncheckedCreateWithoutCountryInput> | EducationDetailsCreateWithoutCountryInput[] | EducationDetailsUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: EducationDetailsCreateOrConnectWithoutCountryInput | EducationDetailsCreateOrConnectWithoutCountryInput[]
    createMany?: EducationDetailsCreateManyCountryInputEnvelope
    connect?: EducationDetailsWhereUniqueInput | EducationDetailsWhereUniqueInput[]
  }

  export type EmploymentDetailsCreateNestedManyWithoutCountryInput = {
    create?: XOR<EmploymentDetailsCreateWithoutCountryInput, EmploymentDetailsUncheckedCreateWithoutCountryInput> | EmploymentDetailsCreateWithoutCountryInput[] | EmploymentDetailsUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: EmploymentDetailsCreateOrConnectWithoutCountryInput | EmploymentDetailsCreateOrConnectWithoutCountryInput[]
    createMany?: EmploymentDetailsCreateManyCountryInputEnvelope
    connect?: EmploymentDetailsWhereUniqueInput | EmploymentDetailsWhereUniqueInput[]
  }

  export type VehicleDetailsCreateNestedManyWithoutCountryInput = {
    create?: XOR<VehicleDetailsCreateWithoutCountryInput, VehicleDetailsUncheckedCreateWithoutCountryInput> | VehicleDetailsCreateWithoutCountryInput[] | VehicleDetailsUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: VehicleDetailsCreateOrConnectWithoutCountryInput | VehicleDetailsCreateOrConnectWithoutCountryInput[]
    createMany?: VehicleDetailsCreateManyCountryInputEnvelope
    connect?: VehicleDetailsWhereUniqueInput | VehicleDetailsWhereUniqueInput[]
  }

  export type PersonalDetailsUncheckedCreateNestedManyWithoutCountryInput = {
    create?: XOR<PersonalDetailsCreateWithoutCountryInput, PersonalDetailsUncheckedCreateWithoutCountryInput> | PersonalDetailsCreateWithoutCountryInput[] | PersonalDetailsUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: PersonalDetailsCreateOrConnectWithoutCountryInput | PersonalDetailsCreateOrConnectWithoutCountryInput[]
    createMany?: PersonalDetailsCreateManyCountryInputEnvelope
    connect?: PersonalDetailsWhereUniqueInput | PersonalDetailsWhereUniqueInput[]
  }

  export type FinancialDetailsUncheckedCreateNestedManyWithoutCountryInput = {
    create?: XOR<FinancialDetailsCreateWithoutCountryInput, FinancialDetailsUncheckedCreateWithoutCountryInput> | FinancialDetailsCreateWithoutCountryInput[] | FinancialDetailsUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: FinancialDetailsCreateOrConnectWithoutCountryInput | FinancialDetailsCreateOrConnectWithoutCountryInput[]
    createMany?: FinancialDetailsCreateManyCountryInputEnvelope
    connect?: FinancialDetailsWhereUniqueInput | FinancialDetailsWhereUniqueInput[]
  }

  export type InternetDetailsUncheckedCreateNestedManyWithoutCountryInput = {
    create?: XOR<InternetDetailsCreateWithoutCountryInput, InternetDetailsUncheckedCreateWithoutCountryInput> | InternetDetailsCreateWithoutCountryInput[] | InternetDetailsUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: InternetDetailsCreateOrConnectWithoutCountryInput | InternetDetailsCreateOrConnectWithoutCountryInput[]
    createMany?: InternetDetailsCreateManyCountryInputEnvelope
    connect?: InternetDetailsWhereUniqueInput | InternetDetailsWhereUniqueInput[]
  }

  export type EducationDetailsUncheckedCreateNestedManyWithoutCountryInput = {
    create?: XOR<EducationDetailsCreateWithoutCountryInput, EducationDetailsUncheckedCreateWithoutCountryInput> | EducationDetailsCreateWithoutCountryInput[] | EducationDetailsUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: EducationDetailsCreateOrConnectWithoutCountryInput | EducationDetailsCreateOrConnectWithoutCountryInput[]
    createMany?: EducationDetailsCreateManyCountryInputEnvelope
    connect?: EducationDetailsWhereUniqueInput | EducationDetailsWhereUniqueInput[]
  }

  export type EmploymentDetailsUncheckedCreateNestedManyWithoutCountryInput = {
    create?: XOR<EmploymentDetailsCreateWithoutCountryInput, EmploymentDetailsUncheckedCreateWithoutCountryInput> | EmploymentDetailsCreateWithoutCountryInput[] | EmploymentDetailsUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: EmploymentDetailsCreateOrConnectWithoutCountryInput | EmploymentDetailsCreateOrConnectWithoutCountryInput[]
    createMany?: EmploymentDetailsCreateManyCountryInputEnvelope
    connect?: EmploymentDetailsWhereUniqueInput | EmploymentDetailsWhereUniqueInput[]
  }

  export type VehicleDetailsUncheckedCreateNestedManyWithoutCountryInput = {
    create?: XOR<VehicleDetailsCreateWithoutCountryInput, VehicleDetailsUncheckedCreateWithoutCountryInput> | VehicleDetailsCreateWithoutCountryInput[] | VehicleDetailsUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: VehicleDetailsCreateOrConnectWithoutCountryInput | VehicleDetailsCreateOrConnectWithoutCountryInput[]
    createMany?: VehicleDetailsCreateManyCountryInputEnvelope
    connect?: VehicleDetailsWhereUniqueInput | VehicleDetailsWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type PersonalDetailsUpdateManyWithoutCountryNestedInput = {
    create?: XOR<PersonalDetailsCreateWithoutCountryInput, PersonalDetailsUncheckedCreateWithoutCountryInput> | PersonalDetailsCreateWithoutCountryInput[] | PersonalDetailsUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: PersonalDetailsCreateOrConnectWithoutCountryInput | PersonalDetailsCreateOrConnectWithoutCountryInput[]
    upsert?: PersonalDetailsUpsertWithWhereUniqueWithoutCountryInput | PersonalDetailsUpsertWithWhereUniqueWithoutCountryInput[]
    createMany?: PersonalDetailsCreateManyCountryInputEnvelope
    set?: PersonalDetailsWhereUniqueInput | PersonalDetailsWhereUniqueInput[]
    disconnect?: PersonalDetailsWhereUniqueInput | PersonalDetailsWhereUniqueInput[]
    delete?: PersonalDetailsWhereUniqueInput | PersonalDetailsWhereUniqueInput[]
    connect?: PersonalDetailsWhereUniqueInput | PersonalDetailsWhereUniqueInput[]
    update?: PersonalDetailsUpdateWithWhereUniqueWithoutCountryInput | PersonalDetailsUpdateWithWhereUniqueWithoutCountryInput[]
    updateMany?: PersonalDetailsUpdateManyWithWhereWithoutCountryInput | PersonalDetailsUpdateManyWithWhereWithoutCountryInput[]
    deleteMany?: PersonalDetailsScalarWhereInput | PersonalDetailsScalarWhereInput[]
  }

  export type FinancialDetailsUpdateManyWithoutCountryNestedInput = {
    create?: XOR<FinancialDetailsCreateWithoutCountryInput, FinancialDetailsUncheckedCreateWithoutCountryInput> | FinancialDetailsCreateWithoutCountryInput[] | FinancialDetailsUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: FinancialDetailsCreateOrConnectWithoutCountryInput | FinancialDetailsCreateOrConnectWithoutCountryInput[]
    upsert?: FinancialDetailsUpsertWithWhereUniqueWithoutCountryInput | FinancialDetailsUpsertWithWhereUniqueWithoutCountryInput[]
    createMany?: FinancialDetailsCreateManyCountryInputEnvelope
    set?: FinancialDetailsWhereUniqueInput | FinancialDetailsWhereUniqueInput[]
    disconnect?: FinancialDetailsWhereUniqueInput | FinancialDetailsWhereUniqueInput[]
    delete?: FinancialDetailsWhereUniqueInput | FinancialDetailsWhereUniqueInput[]
    connect?: FinancialDetailsWhereUniqueInput | FinancialDetailsWhereUniqueInput[]
    update?: FinancialDetailsUpdateWithWhereUniqueWithoutCountryInput | FinancialDetailsUpdateWithWhereUniqueWithoutCountryInput[]
    updateMany?: FinancialDetailsUpdateManyWithWhereWithoutCountryInput | FinancialDetailsUpdateManyWithWhereWithoutCountryInput[]
    deleteMany?: FinancialDetailsScalarWhereInput | FinancialDetailsScalarWhereInput[]
  }

  export type InternetDetailsUpdateManyWithoutCountryNestedInput = {
    create?: XOR<InternetDetailsCreateWithoutCountryInput, InternetDetailsUncheckedCreateWithoutCountryInput> | InternetDetailsCreateWithoutCountryInput[] | InternetDetailsUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: InternetDetailsCreateOrConnectWithoutCountryInput | InternetDetailsCreateOrConnectWithoutCountryInput[]
    upsert?: InternetDetailsUpsertWithWhereUniqueWithoutCountryInput | InternetDetailsUpsertWithWhereUniqueWithoutCountryInput[]
    createMany?: InternetDetailsCreateManyCountryInputEnvelope
    set?: InternetDetailsWhereUniqueInput | InternetDetailsWhereUniqueInput[]
    disconnect?: InternetDetailsWhereUniqueInput | InternetDetailsWhereUniqueInput[]
    delete?: InternetDetailsWhereUniqueInput | InternetDetailsWhereUniqueInput[]
    connect?: InternetDetailsWhereUniqueInput | InternetDetailsWhereUniqueInput[]
    update?: InternetDetailsUpdateWithWhereUniqueWithoutCountryInput | InternetDetailsUpdateWithWhereUniqueWithoutCountryInput[]
    updateMany?: InternetDetailsUpdateManyWithWhereWithoutCountryInput | InternetDetailsUpdateManyWithWhereWithoutCountryInput[]
    deleteMany?: InternetDetailsScalarWhereInput | InternetDetailsScalarWhereInput[]
  }

  export type EducationDetailsUpdateManyWithoutCountryNestedInput = {
    create?: XOR<EducationDetailsCreateWithoutCountryInput, EducationDetailsUncheckedCreateWithoutCountryInput> | EducationDetailsCreateWithoutCountryInput[] | EducationDetailsUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: EducationDetailsCreateOrConnectWithoutCountryInput | EducationDetailsCreateOrConnectWithoutCountryInput[]
    upsert?: EducationDetailsUpsertWithWhereUniqueWithoutCountryInput | EducationDetailsUpsertWithWhereUniqueWithoutCountryInput[]
    createMany?: EducationDetailsCreateManyCountryInputEnvelope
    set?: EducationDetailsWhereUniqueInput | EducationDetailsWhereUniqueInput[]
    disconnect?: EducationDetailsWhereUniqueInput | EducationDetailsWhereUniqueInput[]
    delete?: EducationDetailsWhereUniqueInput | EducationDetailsWhereUniqueInput[]
    connect?: EducationDetailsWhereUniqueInput | EducationDetailsWhereUniqueInput[]
    update?: EducationDetailsUpdateWithWhereUniqueWithoutCountryInput | EducationDetailsUpdateWithWhereUniqueWithoutCountryInput[]
    updateMany?: EducationDetailsUpdateManyWithWhereWithoutCountryInput | EducationDetailsUpdateManyWithWhereWithoutCountryInput[]
    deleteMany?: EducationDetailsScalarWhereInput | EducationDetailsScalarWhereInput[]
  }

  export type EmploymentDetailsUpdateManyWithoutCountryNestedInput = {
    create?: XOR<EmploymentDetailsCreateWithoutCountryInput, EmploymentDetailsUncheckedCreateWithoutCountryInput> | EmploymentDetailsCreateWithoutCountryInput[] | EmploymentDetailsUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: EmploymentDetailsCreateOrConnectWithoutCountryInput | EmploymentDetailsCreateOrConnectWithoutCountryInput[]
    upsert?: EmploymentDetailsUpsertWithWhereUniqueWithoutCountryInput | EmploymentDetailsUpsertWithWhereUniqueWithoutCountryInput[]
    createMany?: EmploymentDetailsCreateManyCountryInputEnvelope
    set?: EmploymentDetailsWhereUniqueInput | EmploymentDetailsWhereUniqueInput[]
    disconnect?: EmploymentDetailsWhereUniqueInput | EmploymentDetailsWhereUniqueInput[]
    delete?: EmploymentDetailsWhereUniqueInput | EmploymentDetailsWhereUniqueInput[]
    connect?: EmploymentDetailsWhereUniqueInput | EmploymentDetailsWhereUniqueInput[]
    update?: EmploymentDetailsUpdateWithWhereUniqueWithoutCountryInput | EmploymentDetailsUpdateWithWhereUniqueWithoutCountryInput[]
    updateMany?: EmploymentDetailsUpdateManyWithWhereWithoutCountryInput | EmploymentDetailsUpdateManyWithWhereWithoutCountryInput[]
    deleteMany?: EmploymentDetailsScalarWhereInput | EmploymentDetailsScalarWhereInput[]
  }

  export type VehicleDetailsUpdateManyWithoutCountryNestedInput = {
    create?: XOR<VehicleDetailsCreateWithoutCountryInput, VehicleDetailsUncheckedCreateWithoutCountryInput> | VehicleDetailsCreateWithoutCountryInput[] | VehicleDetailsUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: VehicleDetailsCreateOrConnectWithoutCountryInput | VehicleDetailsCreateOrConnectWithoutCountryInput[]
    upsert?: VehicleDetailsUpsertWithWhereUniqueWithoutCountryInput | VehicleDetailsUpsertWithWhereUniqueWithoutCountryInput[]
    createMany?: VehicleDetailsCreateManyCountryInputEnvelope
    set?: VehicleDetailsWhereUniqueInput | VehicleDetailsWhereUniqueInput[]
    disconnect?: VehicleDetailsWhereUniqueInput | VehicleDetailsWhereUniqueInput[]
    delete?: VehicleDetailsWhereUniqueInput | VehicleDetailsWhereUniqueInput[]
    connect?: VehicleDetailsWhereUniqueInput | VehicleDetailsWhereUniqueInput[]
    update?: VehicleDetailsUpdateWithWhereUniqueWithoutCountryInput | VehicleDetailsUpdateWithWhereUniqueWithoutCountryInput[]
    updateMany?: VehicleDetailsUpdateManyWithWhereWithoutCountryInput | VehicleDetailsUpdateManyWithWhereWithoutCountryInput[]
    deleteMany?: VehicleDetailsScalarWhereInput | VehicleDetailsScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PersonalDetailsUncheckedUpdateManyWithoutCountryNestedInput = {
    create?: XOR<PersonalDetailsCreateWithoutCountryInput, PersonalDetailsUncheckedCreateWithoutCountryInput> | PersonalDetailsCreateWithoutCountryInput[] | PersonalDetailsUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: PersonalDetailsCreateOrConnectWithoutCountryInput | PersonalDetailsCreateOrConnectWithoutCountryInput[]
    upsert?: PersonalDetailsUpsertWithWhereUniqueWithoutCountryInput | PersonalDetailsUpsertWithWhereUniqueWithoutCountryInput[]
    createMany?: PersonalDetailsCreateManyCountryInputEnvelope
    set?: PersonalDetailsWhereUniqueInput | PersonalDetailsWhereUniqueInput[]
    disconnect?: PersonalDetailsWhereUniqueInput | PersonalDetailsWhereUniqueInput[]
    delete?: PersonalDetailsWhereUniqueInput | PersonalDetailsWhereUniqueInput[]
    connect?: PersonalDetailsWhereUniqueInput | PersonalDetailsWhereUniqueInput[]
    update?: PersonalDetailsUpdateWithWhereUniqueWithoutCountryInput | PersonalDetailsUpdateWithWhereUniqueWithoutCountryInput[]
    updateMany?: PersonalDetailsUpdateManyWithWhereWithoutCountryInput | PersonalDetailsUpdateManyWithWhereWithoutCountryInput[]
    deleteMany?: PersonalDetailsScalarWhereInput | PersonalDetailsScalarWhereInput[]
  }

  export type FinancialDetailsUncheckedUpdateManyWithoutCountryNestedInput = {
    create?: XOR<FinancialDetailsCreateWithoutCountryInput, FinancialDetailsUncheckedCreateWithoutCountryInput> | FinancialDetailsCreateWithoutCountryInput[] | FinancialDetailsUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: FinancialDetailsCreateOrConnectWithoutCountryInput | FinancialDetailsCreateOrConnectWithoutCountryInput[]
    upsert?: FinancialDetailsUpsertWithWhereUniqueWithoutCountryInput | FinancialDetailsUpsertWithWhereUniqueWithoutCountryInput[]
    createMany?: FinancialDetailsCreateManyCountryInputEnvelope
    set?: FinancialDetailsWhereUniqueInput | FinancialDetailsWhereUniqueInput[]
    disconnect?: FinancialDetailsWhereUniqueInput | FinancialDetailsWhereUniqueInput[]
    delete?: FinancialDetailsWhereUniqueInput | FinancialDetailsWhereUniqueInput[]
    connect?: FinancialDetailsWhereUniqueInput | FinancialDetailsWhereUniqueInput[]
    update?: FinancialDetailsUpdateWithWhereUniqueWithoutCountryInput | FinancialDetailsUpdateWithWhereUniqueWithoutCountryInput[]
    updateMany?: FinancialDetailsUpdateManyWithWhereWithoutCountryInput | FinancialDetailsUpdateManyWithWhereWithoutCountryInput[]
    deleteMany?: FinancialDetailsScalarWhereInput | FinancialDetailsScalarWhereInput[]
  }

  export type InternetDetailsUncheckedUpdateManyWithoutCountryNestedInput = {
    create?: XOR<InternetDetailsCreateWithoutCountryInput, InternetDetailsUncheckedCreateWithoutCountryInput> | InternetDetailsCreateWithoutCountryInput[] | InternetDetailsUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: InternetDetailsCreateOrConnectWithoutCountryInput | InternetDetailsCreateOrConnectWithoutCountryInput[]
    upsert?: InternetDetailsUpsertWithWhereUniqueWithoutCountryInput | InternetDetailsUpsertWithWhereUniqueWithoutCountryInput[]
    createMany?: InternetDetailsCreateManyCountryInputEnvelope
    set?: InternetDetailsWhereUniqueInput | InternetDetailsWhereUniqueInput[]
    disconnect?: InternetDetailsWhereUniqueInput | InternetDetailsWhereUniqueInput[]
    delete?: InternetDetailsWhereUniqueInput | InternetDetailsWhereUniqueInput[]
    connect?: InternetDetailsWhereUniqueInput | InternetDetailsWhereUniqueInput[]
    update?: InternetDetailsUpdateWithWhereUniqueWithoutCountryInput | InternetDetailsUpdateWithWhereUniqueWithoutCountryInput[]
    updateMany?: InternetDetailsUpdateManyWithWhereWithoutCountryInput | InternetDetailsUpdateManyWithWhereWithoutCountryInput[]
    deleteMany?: InternetDetailsScalarWhereInput | InternetDetailsScalarWhereInput[]
  }

  export type EducationDetailsUncheckedUpdateManyWithoutCountryNestedInput = {
    create?: XOR<EducationDetailsCreateWithoutCountryInput, EducationDetailsUncheckedCreateWithoutCountryInput> | EducationDetailsCreateWithoutCountryInput[] | EducationDetailsUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: EducationDetailsCreateOrConnectWithoutCountryInput | EducationDetailsCreateOrConnectWithoutCountryInput[]
    upsert?: EducationDetailsUpsertWithWhereUniqueWithoutCountryInput | EducationDetailsUpsertWithWhereUniqueWithoutCountryInput[]
    createMany?: EducationDetailsCreateManyCountryInputEnvelope
    set?: EducationDetailsWhereUniqueInput | EducationDetailsWhereUniqueInput[]
    disconnect?: EducationDetailsWhereUniqueInput | EducationDetailsWhereUniqueInput[]
    delete?: EducationDetailsWhereUniqueInput | EducationDetailsWhereUniqueInput[]
    connect?: EducationDetailsWhereUniqueInput | EducationDetailsWhereUniqueInput[]
    update?: EducationDetailsUpdateWithWhereUniqueWithoutCountryInput | EducationDetailsUpdateWithWhereUniqueWithoutCountryInput[]
    updateMany?: EducationDetailsUpdateManyWithWhereWithoutCountryInput | EducationDetailsUpdateManyWithWhereWithoutCountryInput[]
    deleteMany?: EducationDetailsScalarWhereInput | EducationDetailsScalarWhereInput[]
  }

  export type EmploymentDetailsUncheckedUpdateManyWithoutCountryNestedInput = {
    create?: XOR<EmploymentDetailsCreateWithoutCountryInput, EmploymentDetailsUncheckedCreateWithoutCountryInput> | EmploymentDetailsCreateWithoutCountryInput[] | EmploymentDetailsUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: EmploymentDetailsCreateOrConnectWithoutCountryInput | EmploymentDetailsCreateOrConnectWithoutCountryInput[]
    upsert?: EmploymentDetailsUpsertWithWhereUniqueWithoutCountryInput | EmploymentDetailsUpsertWithWhereUniqueWithoutCountryInput[]
    createMany?: EmploymentDetailsCreateManyCountryInputEnvelope
    set?: EmploymentDetailsWhereUniqueInput | EmploymentDetailsWhereUniqueInput[]
    disconnect?: EmploymentDetailsWhereUniqueInput | EmploymentDetailsWhereUniqueInput[]
    delete?: EmploymentDetailsWhereUniqueInput | EmploymentDetailsWhereUniqueInput[]
    connect?: EmploymentDetailsWhereUniqueInput | EmploymentDetailsWhereUniqueInput[]
    update?: EmploymentDetailsUpdateWithWhereUniqueWithoutCountryInput | EmploymentDetailsUpdateWithWhereUniqueWithoutCountryInput[]
    updateMany?: EmploymentDetailsUpdateManyWithWhereWithoutCountryInput | EmploymentDetailsUpdateManyWithWhereWithoutCountryInput[]
    deleteMany?: EmploymentDetailsScalarWhereInput | EmploymentDetailsScalarWhereInput[]
  }

  export type VehicleDetailsUncheckedUpdateManyWithoutCountryNestedInput = {
    create?: XOR<VehicleDetailsCreateWithoutCountryInput, VehicleDetailsUncheckedCreateWithoutCountryInput> | VehicleDetailsCreateWithoutCountryInput[] | VehicleDetailsUncheckedCreateWithoutCountryInput[]
    connectOrCreate?: VehicleDetailsCreateOrConnectWithoutCountryInput | VehicleDetailsCreateOrConnectWithoutCountryInput[]
    upsert?: VehicleDetailsUpsertWithWhereUniqueWithoutCountryInput | VehicleDetailsUpsertWithWhereUniqueWithoutCountryInput[]
    createMany?: VehicleDetailsCreateManyCountryInputEnvelope
    set?: VehicleDetailsWhereUniqueInput | VehicleDetailsWhereUniqueInput[]
    disconnect?: VehicleDetailsWhereUniqueInput | VehicleDetailsWhereUniqueInput[]
    delete?: VehicleDetailsWhereUniqueInput | VehicleDetailsWhereUniqueInput[]
    connect?: VehicleDetailsWhereUniqueInput | VehicleDetailsWhereUniqueInput[]
    update?: VehicleDetailsUpdateWithWhereUniqueWithoutCountryInput | VehicleDetailsUpdateWithWhereUniqueWithoutCountryInput[]
    updateMany?: VehicleDetailsUpdateManyWithWhereWithoutCountryInput | VehicleDetailsUpdateManyWithWhereWithoutCountryInput[]
    deleteMany?: VehicleDetailsScalarWhereInput | VehicleDetailsScalarWhereInput[]
  }

  export type CountriesCreateNestedOneWithoutPersonalDetailsInput = {
    create?: XOR<CountriesCreateWithoutPersonalDetailsInput, CountriesUncheckedCreateWithoutPersonalDetailsInput>
    connectOrCreate?: CountriesCreateOrConnectWithoutPersonalDetailsInput
    connect?: CountriesWhereUniqueInput
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CountriesUpdateOneRequiredWithoutPersonalDetailsNestedInput = {
    create?: XOR<CountriesCreateWithoutPersonalDetailsInput, CountriesUncheckedCreateWithoutPersonalDetailsInput>
    connectOrCreate?: CountriesCreateOrConnectWithoutPersonalDetailsInput
    upsert?: CountriesUpsertWithoutPersonalDetailsInput
    connect?: CountriesWhereUniqueInput
    update?: XOR<XOR<CountriesUpdateToOneWithWhereWithoutPersonalDetailsInput, CountriesUpdateWithoutPersonalDetailsInput>, CountriesUncheckedUpdateWithoutPersonalDetailsInput>
  }

  export type CountriesCreateNestedOneWithoutFinancialDetailsInput = {
    create?: XOR<CountriesCreateWithoutFinancialDetailsInput, CountriesUncheckedCreateWithoutFinancialDetailsInput>
    connectOrCreate?: CountriesCreateOrConnectWithoutFinancialDetailsInput
    connect?: CountriesWhereUniqueInput
  }

  export type CountriesUpdateOneRequiredWithoutFinancialDetailsNestedInput = {
    create?: XOR<CountriesCreateWithoutFinancialDetailsInput, CountriesUncheckedCreateWithoutFinancialDetailsInput>
    connectOrCreate?: CountriesCreateOrConnectWithoutFinancialDetailsInput
    upsert?: CountriesUpsertWithoutFinancialDetailsInput
    connect?: CountriesWhereUniqueInput
    update?: XOR<XOR<CountriesUpdateToOneWithWhereWithoutFinancialDetailsInput, CountriesUpdateWithoutFinancialDetailsInput>, CountriesUncheckedUpdateWithoutFinancialDetailsInput>
  }

  export type CountriesCreateNestedOneWithoutInternetDetailsInput = {
    create?: XOR<CountriesCreateWithoutInternetDetailsInput, CountriesUncheckedCreateWithoutInternetDetailsInput>
    connectOrCreate?: CountriesCreateOrConnectWithoutInternetDetailsInput
    connect?: CountriesWhereUniqueInput
  }

  export type CountriesUpdateOneRequiredWithoutInternetDetailsNestedInput = {
    create?: XOR<CountriesCreateWithoutInternetDetailsInput, CountriesUncheckedCreateWithoutInternetDetailsInput>
    connectOrCreate?: CountriesCreateOrConnectWithoutInternetDetailsInput
    upsert?: CountriesUpsertWithoutInternetDetailsInput
    connect?: CountriesWhereUniqueInput
    update?: XOR<XOR<CountriesUpdateToOneWithWhereWithoutInternetDetailsInput, CountriesUpdateWithoutInternetDetailsInput>, CountriesUncheckedUpdateWithoutInternetDetailsInput>
  }

  export type CountriesCreateNestedOneWithoutEducationDetailsInput = {
    create?: XOR<CountriesCreateWithoutEducationDetailsInput, CountriesUncheckedCreateWithoutEducationDetailsInput>
    connectOrCreate?: CountriesCreateOrConnectWithoutEducationDetailsInput
    connect?: CountriesWhereUniqueInput
  }

  export type CountriesUpdateOneRequiredWithoutEducationDetailsNestedInput = {
    create?: XOR<CountriesCreateWithoutEducationDetailsInput, CountriesUncheckedCreateWithoutEducationDetailsInput>
    connectOrCreate?: CountriesCreateOrConnectWithoutEducationDetailsInput
    upsert?: CountriesUpsertWithoutEducationDetailsInput
    connect?: CountriesWhereUniqueInput
    update?: XOR<XOR<CountriesUpdateToOneWithWhereWithoutEducationDetailsInput, CountriesUpdateWithoutEducationDetailsInput>, CountriesUncheckedUpdateWithoutEducationDetailsInput>
  }

  export type CountriesCreateNestedOneWithoutEmploymentDetailsInput = {
    create?: XOR<CountriesCreateWithoutEmploymentDetailsInput, CountriesUncheckedCreateWithoutEmploymentDetailsInput>
    connectOrCreate?: CountriesCreateOrConnectWithoutEmploymentDetailsInput
    connect?: CountriesWhereUniqueInput
  }

  export type CountriesUpdateOneRequiredWithoutEmploymentDetailsNestedInput = {
    create?: XOR<CountriesCreateWithoutEmploymentDetailsInput, CountriesUncheckedCreateWithoutEmploymentDetailsInput>
    connectOrCreate?: CountriesCreateOrConnectWithoutEmploymentDetailsInput
    upsert?: CountriesUpsertWithoutEmploymentDetailsInput
    connect?: CountriesWhereUniqueInput
    update?: XOR<XOR<CountriesUpdateToOneWithWhereWithoutEmploymentDetailsInput, CountriesUpdateWithoutEmploymentDetailsInput>, CountriesUncheckedUpdateWithoutEmploymentDetailsInput>
  }

  export type CountriesCreateNestedOneWithoutVehicleDetailsInput = {
    create?: XOR<CountriesCreateWithoutVehicleDetailsInput, CountriesUncheckedCreateWithoutVehicleDetailsInput>
    connectOrCreate?: CountriesCreateOrConnectWithoutVehicleDetailsInput
    connect?: CountriesWhereUniqueInput
  }

  export type CountriesUpdateOneRequiredWithoutVehicleDetailsNestedInput = {
    create?: XOR<CountriesCreateWithoutVehicleDetailsInput, CountriesUncheckedCreateWithoutVehicleDetailsInput>
    connectOrCreate?: CountriesCreateOrConnectWithoutVehicleDetailsInput
    upsert?: CountriesUpsertWithoutVehicleDetailsInput
    connect?: CountriesWhereUniqueInput
    update?: XOR<XOR<CountriesUpdateToOneWithWhereWithoutVehicleDetailsInput, CountriesUpdateWithoutVehicleDetailsInput>, CountriesUncheckedUpdateWithoutVehicleDetailsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type PersonalDetailsCreateWithoutCountryInput = {
    Name?: string | null
    Address?: string | null
    Postcode?: string | null
    City?: string | null
    DateOfBirth?: Date | string | null
    Gender?: string | null
    Phone?: string | null
    MothersMaidenName?: string | null
    Email?: string | null
    Ethnicity?: string | null
    ZodiacSign?: string | null
    Age?: number | null
    Height?: number | null
    Weight?: number | null
    EyeColor?: string | null
    HairColor?: string | null
  }

  export type PersonalDetailsUncheckedCreateWithoutCountryInput = {
    ID?: number
    Name?: string | null
    Address?: string | null
    Postcode?: string | null
    City?: string | null
    DateOfBirth?: Date | string | null
    Gender?: string | null
    Phone?: string | null
    MothersMaidenName?: string | null
    Email?: string | null
    Ethnicity?: string | null
    ZodiacSign?: string | null
    Age?: number | null
    Height?: number | null
    Weight?: number | null
    EyeColor?: string | null
    HairColor?: string | null
  }

  export type PersonalDetailsCreateOrConnectWithoutCountryInput = {
    where: PersonalDetailsWhereUniqueInput
    create: XOR<PersonalDetailsCreateWithoutCountryInput, PersonalDetailsUncheckedCreateWithoutCountryInput>
  }

  export type PersonalDetailsCreateManyCountryInputEnvelope = {
    data: PersonalDetailsCreateManyCountryInput | PersonalDetailsCreateManyCountryInput[]
    skipDuplicates?: boolean
  }

  export type FinancialDetailsCreateWithoutCountryInput = {
    CreditCardType?: string | null
    CreditCardNumber?: string | null
    CreditCardExpiry?: string | null
    CreditCardCVV2?: number | null
  }

  export type FinancialDetailsUncheckedCreateWithoutCountryInput = {
    ID?: number
    CreditCardType?: string | null
    CreditCardNumber?: string | null
    CreditCardExpiry?: string | null
    CreditCardCVV2?: number | null
  }

  export type FinancialDetailsCreateOrConnectWithoutCountryInput = {
    where: FinancialDetailsWhereUniqueInput
    create: XOR<FinancialDetailsCreateWithoutCountryInput, FinancialDetailsUncheckedCreateWithoutCountryInput>
  }

  export type FinancialDetailsCreateManyCountryInputEnvelope = {
    data: FinancialDetailsCreateManyCountryInput | FinancialDetailsCreateManyCountryInput[]
    skipDuplicates?: boolean
  }

  export type InternetDetailsCreateWithoutCountryInput = {
    UserName?: string | null
    Password?: string | null
    IPv4Address?: string | null
    IPv6Address?: string | null
    UserAgent?: string | null
  }

  export type InternetDetailsUncheckedCreateWithoutCountryInput = {
    ID?: number
    UserName?: string | null
    Password?: string | null
    IPv4Address?: string | null
    IPv6Address?: string | null
    UserAgent?: string | null
  }

  export type InternetDetailsCreateOrConnectWithoutCountryInput = {
    where: InternetDetailsWhereUniqueInput
    create: XOR<InternetDetailsCreateWithoutCountryInput, InternetDetailsUncheckedCreateWithoutCountryInput>
  }

  export type InternetDetailsCreateManyCountryInputEnvelope = {
    data: InternetDetailsCreateManyCountryInput | InternetDetailsCreateManyCountryInput[]
    skipDuplicates?: boolean
  }

  export type EducationDetailsCreateWithoutCountryInput = {
    Qualification?: string | null
    Institution?: string | null
  }

  export type EducationDetailsUncheckedCreateWithoutCountryInput = {
    ID?: number
    Qualification?: string | null
    Institution?: string | null
  }

  export type EducationDetailsCreateOrConnectWithoutCountryInput = {
    where: EducationDetailsWhereUniqueInput
    create: XOR<EducationDetailsCreateWithoutCountryInput, EducationDetailsUncheckedCreateWithoutCountryInput>
  }

  export type EducationDetailsCreateManyCountryInputEnvelope = {
    data: EducationDetailsCreateManyCountryInput | EducationDetailsCreateManyCountryInput[]
    skipDuplicates?: boolean
  }

  export type EmploymentDetailsCreateWithoutCountryInput = {
    CompanyName?: string | null
    Salary?: string | null
    CompanyAddress?: string | null
    JobTitle?: string | null
    CompanyPhone?: string | null
    CompanyEmail?: string | null
  }

  export type EmploymentDetailsUncheckedCreateWithoutCountryInput = {
    ID?: number
    CompanyName?: string | null
    Salary?: string | null
    CompanyAddress?: string | null
    JobTitle?: string | null
    CompanyPhone?: string | null
    CompanyEmail?: string | null
  }

  export type EmploymentDetailsCreateOrConnectWithoutCountryInput = {
    where: EmploymentDetailsWhereUniqueInput
    create: XOR<EmploymentDetailsCreateWithoutCountryInput, EmploymentDetailsUncheckedCreateWithoutCountryInput>
  }

  export type EmploymentDetailsCreateManyCountryInputEnvelope = {
    data: EmploymentDetailsCreateManyCountryInput | EmploymentDetailsCreateManyCountryInput[]
    skipDuplicates?: boolean
  }

  export type VehicleDetailsCreateWithoutCountryInput = {
    VehicleName?: string | null
    LicensePlate?: string | null
    VIN?: string | null
    Color?: string | null
  }

  export type VehicleDetailsUncheckedCreateWithoutCountryInput = {
    ID?: number
    VehicleName?: string | null
    LicensePlate?: string | null
    VIN?: string | null
    Color?: string | null
  }

  export type VehicleDetailsCreateOrConnectWithoutCountryInput = {
    where: VehicleDetailsWhereUniqueInput
    create: XOR<VehicleDetailsCreateWithoutCountryInput, VehicleDetailsUncheckedCreateWithoutCountryInput>
  }

  export type VehicleDetailsCreateManyCountryInputEnvelope = {
    data: VehicleDetailsCreateManyCountryInput | VehicleDetailsCreateManyCountryInput[]
    skipDuplicates?: boolean
  }

  export type PersonalDetailsUpsertWithWhereUniqueWithoutCountryInput = {
    where: PersonalDetailsWhereUniqueInput
    update: XOR<PersonalDetailsUpdateWithoutCountryInput, PersonalDetailsUncheckedUpdateWithoutCountryInput>
    create: XOR<PersonalDetailsCreateWithoutCountryInput, PersonalDetailsUncheckedCreateWithoutCountryInput>
  }

  export type PersonalDetailsUpdateWithWhereUniqueWithoutCountryInput = {
    where: PersonalDetailsWhereUniqueInput
    data: XOR<PersonalDetailsUpdateWithoutCountryInput, PersonalDetailsUncheckedUpdateWithoutCountryInput>
  }

  export type PersonalDetailsUpdateManyWithWhereWithoutCountryInput = {
    where: PersonalDetailsScalarWhereInput
    data: XOR<PersonalDetailsUpdateManyMutationInput, PersonalDetailsUncheckedUpdateManyWithoutCountryInput>
  }

  export type PersonalDetailsScalarWhereInput = {
    AND?: PersonalDetailsScalarWhereInput | PersonalDetailsScalarWhereInput[]
    OR?: PersonalDetailsScalarWhereInput[]
    NOT?: PersonalDetailsScalarWhereInput | PersonalDetailsScalarWhereInput[]
    ID?: IntFilter<"PersonalDetails"> | number
    Name?: StringNullableFilter<"PersonalDetails"> | string | null
    Address?: StringNullableFilter<"PersonalDetails"> | string | null
    Postcode?: StringNullableFilter<"PersonalDetails"> | string | null
    City?: StringNullableFilter<"PersonalDetails"> | string | null
    DateOfBirth?: DateTimeNullableFilter<"PersonalDetails"> | Date | string | null
    Gender?: StringNullableFilter<"PersonalDetails"> | string | null
    Phone?: StringNullableFilter<"PersonalDetails"> | string | null
    MothersMaidenName?: StringNullableFilter<"PersonalDetails"> | string | null
    Email?: StringNullableFilter<"PersonalDetails"> | string | null
    Ethnicity?: StringNullableFilter<"PersonalDetails"> | string | null
    ZodiacSign?: StringNullableFilter<"PersonalDetails"> | string | null
    Age?: IntNullableFilter<"PersonalDetails"> | number | null
    Height?: FloatNullableFilter<"PersonalDetails"> | number | null
    Weight?: FloatNullableFilter<"PersonalDetails"> | number | null
    EyeColor?: StringNullableFilter<"PersonalDetails"> | string | null
    HairColor?: StringNullableFilter<"PersonalDetails"> | string | null
    CountryID?: IntFilter<"PersonalDetails"> | number
  }

  export type FinancialDetailsUpsertWithWhereUniqueWithoutCountryInput = {
    where: FinancialDetailsWhereUniqueInput
    update: XOR<FinancialDetailsUpdateWithoutCountryInput, FinancialDetailsUncheckedUpdateWithoutCountryInput>
    create: XOR<FinancialDetailsCreateWithoutCountryInput, FinancialDetailsUncheckedCreateWithoutCountryInput>
  }

  export type FinancialDetailsUpdateWithWhereUniqueWithoutCountryInput = {
    where: FinancialDetailsWhereUniqueInput
    data: XOR<FinancialDetailsUpdateWithoutCountryInput, FinancialDetailsUncheckedUpdateWithoutCountryInput>
  }

  export type FinancialDetailsUpdateManyWithWhereWithoutCountryInput = {
    where: FinancialDetailsScalarWhereInput
    data: XOR<FinancialDetailsUpdateManyMutationInput, FinancialDetailsUncheckedUpdateManyWithoutCountryInput>
  }

  export type FinancialDetailsScalarWhereInput = {
    AND?: FinancialDetailsScalarWhereInput | FinancialDetailsScalarWhereInput[]
    OR?: FinancialDetailsScalarWhereInput[]
    NOT?: FinancialDetailsScalarWhereInput | FinancialDetailsScalarWhereInput[]
    ID?: IntFilter<"FinancialDetails"> | number
    CreditCardType?: StringNullableFilter<"FinancialDetails"> | string | null
    CreditCardNumber?: StringNullableFilter<"FinancialDetails"> | string | null
    CreditCardExpiry?: StringNullableFilter<"FinancialDetails"> | string | null
    CreditCardCVV2?: IntNullableFilter<"FinancialDetails"> | number | null
    CountryID?: IntFilter<"FinancialDetails"> | number
  }

  export type InternetDetailsUpsertWithWhereUniqueWithoutCountryInput = {
    where: InternetDetailsWhereUniqueInput
    update: XOR<InternetDetailsUpdateWithoutCountryInput, InternetDetailsUncheckedUpdateWithoutCountryInput>
    create: XOR<InternetDetailsCreateWithoutCountryInput, InternetDetailsUncheckedCreateWithoutCountryInput>
  }

  export type InternetDetailsUpdateWithWhereUniqueWithoutCountryInput = {
    where: InternetDetailsWhereUniqueInput
    data: XOR<InternetDetailsUpdateWithoutCountryInput, InternetDetailsUncheckedUpdateWithoutCountryInput>
  }

  export type InternetDetailsUpdateManyWithWhereWithoutCountryInput = {
    where: InternetDetailsScalarWhereInput
    data: XOR<InternetDetailsUpdateManyMutationInput, InternetDetailsUncheckedUpdateManyWithoutCountryInput>
  }

  export type InternetDetailsScalarWhereInput = {
    AND?: InternetDetailsScalarWhereInput | InternetDetailsScalarWhereInput[]
    OR?: InternetDetailsScalarWhereInput[]
    NOT?: InternetDetailsScalarWhereInput | InternetDetailsScalarWhereInput[]
    ID?: IntFilter<"InternetDetails"> | number
    UserName?: StringNullableFilter<"InternetDetails"> | string | null
    Password?: StringNullableFilter<"InternetDetails"> | string | null
    IPv4Address?: StringNullableFilter<"InternetDetails"> | string | null
    IPv6Address?: StringNullableFilter<"InternetDetails"> | string | null
    UserAgent?: StringNullableFilter<"InternetDetails"> | string | null
    CountryID?: IntFilter<"InternetDetails"> | number
  }

  export type EducationDetailsUpsertWithWhereUniqueWithoutCountryInput = {
    where: EducationDetailsWhereUniqueInput
    update: XOR<EducationDetailsUpdateWithoutCountryInput, EducationDetailsUncheckedUpdateWithoutCountryInput>
    create: XOR<EducationDetailsCreateWithoutCountryInput, EducationDetailsUncheckedCreateWithoutCountryInput>
  }

  export type EducationDetailsUpdateWithWhereUniqueWithoutCountryInput = {
    where: EducationDetailsWhereUniqueInput
    data: XOR<EducationDetailsUpdateWithoutCountryInput, EducationDetailsUncheckedUpdateWithoutCountryInput>
  }

  export type EducationDetailsUpdateManyWithWhereWithoutCountryInput = {
    where: EducationDetailsScalarWhereInput
    data: XOR<EducationDetailsUpdateManyMutationInput, EducationDetailsUncheckedUpdateManyWithoutCountryInput>
  }

  export type EducationDetailsScalarWhereInput = {
    AND?: EducationDetailsScalarWhereInput | EducationDetailsScalarWhereInput[]
    OR?: EducationDetailsScalarWhereInput[]
    NOT?: EducationDetailsScalarWhereInput | EducationDetailsScalarWhereInput[]
    ID?: IntFilter<"EducationDetails"> | number
    Qualification?: StringNullableFilter<"EducationDetails"> | string | null
    Institution?: StringNullableFilter<"EducationDetails"> | string | null
    CountryID?: IntFilter<"EducationDetails"> | number
  }

  export type EmploymentDetailsUpsertWithWhereUniqueWithoutCountryInput = {
    where: EmploymentDetailsWhereUniqueInput
    update: XOR<EmploymentDetailsUpdateWithoutCountryInput, EmploymentDetailsUncheckedUpdateWithoutCountryInput>
    create: XOR<EmploymentDetailsCreateWithoutCountryInput, EmploymentDetailsUncheckedCreateWithoutCountryInput>
  }

  export type EmploymentDetailsUpdateWithWhereUniqueWithoutCountryInput = {
    where: EmploymentDetailsWhereUniqueInput
    data: XOR<EmploymentDetailsUpdateWithoutCountryInput, EmploymentDetailsUncheckedUpdateWithoutCountryInput>
  }

  export type EmploymentDetailsUpdateManyWithWhereWithoutCountryInput = {
    where: EmploymentDetailsScalarWhereInput
    data: XOR<EmploymentDetailsUpdateManyMutationInput, EmploymentDetailsUncheckedUpdateManyWithoutCountryInput>
  }

  export type EmploymentDetailsScalarWhereInput = {
    AND?: EmploymentDetailsScalarWhereInput | EmploymentDetailsScalarWhereInput[]
    OR?: EmploymentDetailsScalarWhereInput[]
    NOT?: EmploymentDetailsScalarWhereInput | EmploymentDetailsScalarWhereInput[]
    ID?: IntFilter<"EmploymentDetails"> | number
    CompanyName?: StringNullableFilter<"EmploymentDetails"> | string | null
    Salary?: StringNullableFilter<"EmploymentDetails"> | string | null
    CompanyAddress?: StringNullableFilter<"EmploymentDetails"> | string | null
    JobTitle?: StringNullableFilter<"EmploymentDetails"> | string | null
    CompanyPhone?: StringNullableFilter<"EmploymentDetails"> | string | null
    CompanyEmail?: StringNullableFilter<"EmploymentDetails"> | string | null
    CountryID?: IntFilter<"EmploymentDetails"> | number
  }

  export type VehicleDetailsUpsertWithWhereUniqueWithoutCountryInput = {
    where: VehicleDetailsWhereUniqueInput
    update: XOR<VehicleDetailsUpdateWithoutCountryInput, VehicleDetailsUncheckedUpdateWithoutCountryInput>
    create: XOR<VehicleDetailsCreateWithoutCountryInput, VehicleDetailsUncheckedCreateWithoutCountryInput>
  }

  export type VehicleDetailsUpdateWithWhereUniqueWithoutCountryInput = {
    where: VehicleDetailsWhereUniqueInput
    data: XOR<VehicleDetailsUpdateWithoutCountryInput, VehicleDetailsUncheckedUpdateWithoutCountryInput>
  }

  export type VehicleDetailsUpdateManyWithWhereWithoutCountryInput = {
    where: VehicleDetailsScalarWhereInput
    data: XOR<VehicleDetailsUpdateManyMutationInput, VehicleDetailsUncheckedUpdateManyWithoutCountryInput>
  }

  export type VehicleDetailsScalarWhereInput = {
    AND?: VehicleDetailsScalarWhereInput | VehicleDetailsScalarWhereInput[]
    OR?: VehicleDetailsScalarWhereInput[]
    NOT?: VehicleDetailsScalarWhereInput | VehicleDetailsScalarWhereInput[]
    ID?: IntFilter<"VehicleDetails"> | number
    VehicleName?: StringNullableFilter<"VehicleDetails"> | string | null
    LicensePlate?: StringNullableFilter<"VehicleDetails"> | string | null
    VIN?: StringNullableFilter<"VehicleDetails"> | string | null
    Color?: StringNullableFilter<"VehicleDetails"> | string | null
    CountryID?: IntFilter<"VehicleDetails"> | number
  }

  export type CountriesCreateWithoutPersonalDetailsInput = {
    CountryName: string
    FinancialDetails?: FinancialDetailsCreateNestedManyWithoutCountryInput
    InternetDetails?: InternetDetailsCreateNestedManyWithoutCountryInput
    EducationDetails?: EducationDetailsCreateNestedManyWithoutCountryInput
    EmploymentDetails?: EmploymentDetailsCreateNestedManyWithoutCountryInput
    VehicleDetails?: VehicleDetailsCreateNestedManyWithoutCountryInput
  }

  export type CountriesUncheckedCreateWithoutPersonalDetailsInput = {
    CountryID?: number
    CountryName: string
    FinancialDetails?: FinancialDetailsUncheckedCreateNestedManyWithoutCountryInput
    InternetDetails?: InternetDetailsUncheckedCreateNestedManyWithoutCountryInput
    EducationDetails?: EducationDetailsUncheckedCreateNestedManyWithoutCountryInput
    EmploymentDetails?: EmploymentDetailsUncheckedCreateNestedManyWithoutCountryInput
    VehicleDetails?: VehicleDetailsUncheckedCreateNestedManyWithoutCountryInput
  }

  export type CountriesCreateOrConnectWithoutPersonalDetailsInput = {
    where: CountriesWhereUniqueInput
    create: XOR<CountriesCreateWithoutPersonalDetailsInput, CountriesUncheckedCreateWithoutPersonalDetailsInput>
  }

  export type CountriesUpsertWithoutPersonalDetailsInput = {
    update: XOR<CountriesUpdateWithoutPersonalDetailsInput, CountriesUncheckedUpdateWithoutPersonalDetailsInput>
    create: XOR<CountriesCreateWithoutPersonalDetailsInput, CountriesUncheckedCreateWithoutPersonalDetailsInput>
    where?: CountriesWhereInput
  }

  export type CountriesUpdateToOneWithWhereWithoutPersonalDetailsInput = {
    where?: CountriesWhereInput
    data: XOR<CountriesUpdateWithoutPersonalDetailsInput, CountriesUncheckedUpdateWithoutPersonalDetailsInput>
  }

  export type CountriesUpdateWithoutPersonalDetailsInput = {
    CountryName?: StringFieldUpdateOperationsInput | string
    FinancialDetails?: FinancialDetailsUpdateManyWithoutCountryNestedInput
    InternetDetails?: InternetDetailsUpdateManyWithoutCountryNestedInput
    EducationDetails?: EducationDetailsUpdateManyWithoutCountryNestedInput
    EmploymentDetails?: EmploymentDetailsUpdateManyWithoutCountryNestedInput
    VehicleDetails?: VehicleDetailsUpdateManyWithoutCountryNestedInput
  }

  export type CountriesUncheckedUpdateWithoutPersonalDetailsInput = {
    CountryID?: IntFieldUpdateOperationsInput | number
    CountryName?: StringFieldUpdateOperationsInput | string
    FinancialDetails?: FinancialDetailsUncheckedUpdateManyWithoutCountryNestedInput
    InternetDetails?: InternetDetailsUncheckedUpdateManyWithoutCountryNestedInput
    EducationDetails?: EducationDetailsUncheckedUpdateManyWithoutCountryNestedInput
    EmploymentDetails?: EmploymentDetailsUncheckedUpdateManyWithoutCountryNestedInput
    VehicleDetails?: VehicleDetailsUncheckedUpdateManyWithoutCountryNestedInput
  }

  export type CountriesCreateWithoutFinancialDetailsInput = {
    CountryName: string
    PersonalDetails?: PersonalDetailsCreateNestedManyWithoutCountryInput
    InternetDetails?: InternetDetailsCreateNestedManyWithoutCountryInput
    EducationDetails?: EducationDetailsCreateNestedManyWithoutCountryInput
    EmploymentDetails?: EmploymentDetailsCreateNestedManyWithoutCountryInput
    VehicleDetails?: VehicleDetailsCreateNestedManyWithoutCountryInput
  }

  export type CountriesUncheckedCreateWithoutFinancialDetailsInput = {
    CountryID?: number
    CountryName: string
    PersonalDetails?: PersonalDetailsUncheckedCreateNestedManyWithoutCountryInput
    InternetDetails?: InternetDetailsUncheckedCreateNestedManyWithoutCountryInput
    EducationDetails?: EducationDetailsUncheckedCreateNestedManyWithoutCountryInput
    EmploymentDetails?: EmploymentDetailsUncheckedCreateNestedManyWithoutCountryInput
    VehicleDetails?: VehicleDetailsUncheckedCreateNestedManyWithoutCountryInput
  }

  export type CountriesCreateOrConnectWithoutFinancialDetailsInput = {
    where: CountriesWhereUniqueInput
    create: XOR<CountriesCreateWithoutFinancialDetailsInput, CountriesUncheckedCreateWithoutFinancialDetailsInput>
  }

  export type CountriesUpsertWithoutFinancialDetailsInput = {
    update: XOR<CountriesUpdateWithoutFinancialDetailsInput, CountriesUncheckedUpdateWithoutFinancialDetailsInput>
    create: XOR<CountriesCreateWithoutFinancialDetailsInput, CountriesUncheckedCreateWithoutFinancialDetailsInput>
    where?: CountriesWhereInput
  }

  export type CountriesUpdateToOneWithWhereWithoutFinancialDetailsInput = {
    where?: CountriesWhereInput
    data: XOR<CountriesUpdateWithoutFinancialDetailsInput, CountriesUncheckedUpdateWithoutFinancialDetailsInput>
  }

  export type CountriesUpdateWithoutFinancialDetailsInput = {
    CountryName?: StringFieldUpdateOperationsInput | string
    PersonalDetails?: PersonalDetailsUpdateManyWithoutCountryNestedInput
    InternetDetails?: InternetDetailsUpdateManyWithoutCountryNestedInput
    EducationDetails?: EducationDetailsUpdateManyWithoutCountryNestedInput
    EmploymentDetails?: EmploymentDetailsUpdateManyWithoutCountryNestedInput
    VehicleDetails?: VehicleDetailsUpdateManyWithoutCountryNestedInput
  }

  export type CountriesUncheckedUpdateWithoutFinancialDetailsInput = {
    CountryID?: IntFieldUpdateOperationsInput | number
    CountryName?: StringFieldUpdateOperationsInput | string
    PersonalDetails?: PersonalDetailsUncheckedUpdateManyWithoutCountryNestedInput
    InternetDetails?: InternetDetailsUncheckedUpdateManyWithoutCountryNestedInput
    EducationDetails?: EducationDetailsUncheckedUpdateManyWithoutCountryNestedInput
    EmploymentDetails?: EmploymentDetailsUncheckedUpdateManyWithoutCountryNestedInput
    VehicleDetails?: VehicleDetailsUncheckedUpdateManyWithoutCountryNestedInput
  }

  export type CountriesCreateWithoutInternetDetailsInput = {
    CountryName: string
    PersonalDetails?: PersonalDetailsCreateNestedManyWithoutCountryInput
    FinancialDetails?: FinancialDetailsCreateNestedManyWithoutCountryInput
    EducationDetails?: EducationDetailsCreateNestedManyWithoutCountryInput
    EmploymentDetails?: EmploymentDetailsCreateNestedManyWithoutCountryInput
    VehicleDetails?: VehicleDetailsCreateNestedManyWithoutCountryInput
  }

  export type CountriesUncheckedCreateWithoutInternetDetailsInput = {
    CountryID?: number
    CountryName: string
    PersonalDetails?: PersonalDetailsUncheckedCreateNestedManyWithoutCountryInput
    FinancialDetails?: FinancialDetailsUncheckedCreateNestedManyWithoutCountryInput
    EducationDetails?: EducationDetailsUncheckedCreateNestedManyWithoutCountryInput
    EmploymentDetails?: EmploymentDetailsUncheckedCreateNestedManyWithoutCountryInput
    VehicleDetails?: VehicleDetailsUncheckedCreateNestedManyWithoutCountryInput
  }

  export type CountriesCreateOrConnectWithoutInternetDetailsInput = {
    where: CountriesWhereUniqueInput
    create: XOR<CountriesCreateWithoutInternetDetailsInput, CountriesUncheckedCreateWithoutInternetDetailsInput>
  }

  export type CountriesUpsertWithoutInternetDetailsInput = {
    update: XOR<CountriesUpdateWithoutInternetDetailsInput, CountriesUncheckedUpdateWithoutInternetDetailsInput>
    create: XOR<CountriesCreateWithoutInternetDetailsInput, CountriesUncheckedCreateWithoutInternetDetailsInput>
    where?: CountriesWhereInput
  }

  export type CountriesUpdateToOneWithWhereWithoutInternetDetailsInput = {
    where?: CountriesWhereInput
    data: XOR<CountriesUpdateWithoutInternetDetailsInput, CountriesUncheckedUpdateWithoutInternetDetailsInput>
  }

  export type CountriesUpdateWithoutInternetDetailsInput = {
    CountryName?: StringFieldUpdateOperationsInput | string
    PersonalDetails?: PersonalDetailsUpdateManyWithoutCountryNestedInput
    FinancialDetails?: FinancialDetailsUpdateManyWithoutCountryNestedInput
    EducationDetails?: EducationDetailsUpdateManyWithoutCountryNestedInput
    EmploymentDetails?: EmploymentDetailsUpdateManyWithoutCountryNestedInput
    VehicleDetails?: VehicleDetailsUpdateManyWithoutCountryNestedInput
  }

  export type CountriesUncheckedUpdateWithoutInternetDetailsInput = {
    CountryID?: IntFieldUpdateOperationsInput | number
    CountryName?: StringFieldUpdateOperationsInput | string
    PersonalDetails?: PersonalDetailsUncheckedUpdateManyWithoutCountryNestedInput
    FinancialDetails?: FinancialDetailsUncheckedUpdateManyWithoutCountryNestedInput
    EducationDetails?: EducationDetailsUncheckedUpdateManyWithoutCountryNestedInput
    EmploymentDetails?: EmploymentDetailsUncheckedUpdateManyWithoutCountryNestedInput
    VehicleDetails?: VehicleDetailsUncheckedUpdateManyWithoutCountryNestedInput
  }

  export type CountriesCreateWithoutEducationDetailsInput = {
    CountryName: string
    PersonalDetails?: PersonalDetailsCreateNestedManyWithoutCountryInput
    FinancialDetails?: FinancialDetailsCreateNestedManyWithoutCountryInput
    InternetDetails?: InternetDetailsCreateNestedManyWithoutCountryInput
    EmploymentDetails?: EmploymentDetailsCreateNestedManyWithoutCountryInput
    VehicleDetails?: VehicleDetailsCreateNestedManyWithoutCountryInput
  }

  export type CountriesUncheckedCreateWithoutEducationDetailsInput = {
    CountryID?: number
    CountryName: string
    PersonalDetails?: PersonalDetailsUncheckedCreateNestedManyWithoutCountryInput
    FinancialDetails?: FinancialDetailsUncheckedCreateNestedManyWithoutCountryInput
    InternetDetails?: InternetDetailsUncheckedCreateNestedManyWithoutCountryInput
    EmploymentDetails?: EmploymentDetailsUncheckedCreateNestedManyWithoutCountryInput
    VehicleDetails?: VehicleDetailsUncheckedCreateNestedManyWithoutCountryInput
  }

  export type CountriesCreateOrConnectWithoutEducationDetailsInput = {
    where: CountriesWhereUniqueInput
    create: XOR<CountriesCreateWithoutEducationDetailsInput, CountriesUncheckedCreateWithoutEducationDetailsInput>
  }

  export type CountriesUpsertWithoutEducationDetailsInput = {
    update: XOR<CountriesUpdateWithoutEducationDetailsInput, CountriesUncheckedUpdateWithoutEducationDetailsInput>
    create: XOR<CountriesCreateWithoutEducationDetailsInput, CountriesUncheckedCreateWithoutEducationDetailsInput>
    where?: CountriesWhereInput
  }

  export type CountriesUpdateToOneWithWhereWithoutEducationDetailsInput = {
    where?: CountriesWhereInput
    data: XOR<CountriesUpdateWithoutEducationDetailsInput, CountriesUncheckedUpdateWithoutEducationDetailsInput>
  }

  export type CountriesUpdateWithoutEducationDetailsInput = {
    CountryName?: StringFieldUpdateOperationsInput | string
    PersonalDetails?: PersonalDetailsUpdateManyWithoutCountryNestedInput
    FinancialDetails?: FinancialDetailsUpdateManyWithoutCountryNestedInput
    InternetDetails?: InternetDetailsUpdateManyWithoutCountryNestedInput
    EmploymentDetails?: EmploymentDetailsUpdateManyWithoutCountryNestedInput
    VehicleDetails?: VehicleDetailsUpdateManyWithoutCountryNestedInput
  }

  export type CountriesUncheckedUpdateWithoutEducationDetailsInput = {
    CountryID?: IntFieldUpdateOperationsInput | number
    CountryName?: StringFieldUpdateOperationsInput | string
    PersonalDetails?: PersonalDetailsUncheckedUpdateManyWithoutCountryNestedInput
    FinancialDetails?: FinancialDetailsUncheckedUpdateManyWithoutCountryNestedInput
    InternetDetails?: InternetDetailsUncheckedUpdateManyWithoutCountryNestedInput
    EmploymentDetails?: EmploymentDetailsUncheckedUpdateManyWithoutCountryNestedInput
    VehicleDetails?: VehicleDetailsUncheckedUpdateManyWithoutCountryNestedInput
  }

  export type CountriesCreateWithoutEmploymentDetailsInput = {
    CountryName: string
    PersonalDetails?: PersonalDetailsCreateNestedManyWithoutCountryInput
    FinancialDetails?: FinancialDetailsCreateNestedManyWithoutCountryInput
    InternetDetails?: InternetDetailsCreateNestedManyWithoutCountryInput
    EducationDetails?: EducationDetailsCreateNestedManyWithoutCountryInput
    VehicleDetails?: VehicleDetailsCreateNestedManyWithoutCountryInput
  }

  export type CountriesUncheckedCreateWithoutEmploymentDetailsInput = {
    CountryID?: number
    CountryName: string
    PersonalDetails?: PersonalDetailsUncheckedCreateNestedManyWithoutCountryInput
    FinancialDetails?: FinancialDetailsUncheckedCreateNestedManyWithoutCountryInput
    InternetDetails?: InternetDetailsUncheckedCreateNestedManyWithoutCountryInput
    EducationDetails?: EducationDetailsUncheckedCreateNestedManyWithoutCountryInput
    VehicleDetails?: VehicleDetailsUncheckedCreateNestedManyWithoutCountryInput
  }

  export type CountriesCreateOrConnectWithoutEmploymentDetailsInput = {
    where: CountriesWhereUniqueInput
    create: XOR<CountriesCreateWithoutEmploymentDetailsInput, CountriesUncheckedCreateWithoutEmploymentDetailsInput>
  }

  export type CountriesUpsertWithoutEmploymentDetailsInput = {
    update: XOR<CountriesUpdateWithoutEmploymentDetailsInput, CountriesUncheckedUpdateWithoutEmploymentDetailsInput>
    create: XOR<CountriesCreateWithoutEmploymentDetailsInput, CountriesUncheckedCreateWithoutEmploymentDetailsInput>
    where?: CountriesWhereInput
  }

  export type CountriesUpdateToOneWithWhereWithoutEmploymentDetailsInput = {
    where?: CountriesWhereInput
    data: XOR<CountriesUpdateWithoutEmploymentDetailsInput, CountriesUncheckedUpdateWithoutEmploymentDetailsInput>
  }

  export type CountriesUpdateWithoutEmploymentDetailsInput = {
    CountryName?: StringFieldUpdateOperationsInput | string
    PersonalDetails?: PersonalDetailsUpdateManyWithoutCountryNestedInput
    FinancialDetails?: FinancialDetailsUpdateManyWithoutCountryNestedInput
    InternetDetails?: InternetDetailsUpdateManyWithoutCountryNestedInput
    EducationDetails?: EducationDetailsUpdateManyWithoutCountryNestedInput
    VehicleDetails?: VehicleDetailsUpdateManyWithoutCountryNestedInput
  }

  export type CountriesUncheckedUpdateWithoutEmploymentDetailsInput = {
    CountryID?: IntFieldUpdateOperationsInput | number
    CountryName?: StringFieldUpdateOperationsInput | string
    PersonalDetails?: PersonalDetailsUncheckedUpdateManyWithoutCountryNestedInput
    FinancialDetails?: FinancialDetailsUncheckedUpdateManyWithoutCountryNestedInput
    InternetDetails?: InternetDetailsUncheckedUpdateManyWithoutCountryNestedInput
    EducationDetails?: EducationDetailsUncheckedUpdateManyWithoutCountryNestedInput
    VehicleDetails?: VehicleDetailsUncheckedUpdateManyWithoutCountryNestedInput
  }

  export type CountriesCreateWithoutVehicleDetailsInput = {
    CountryName: string
    PersonalDetails?: PersonalDetailsCreateNestedManyWithoutCountryInput
    FinancialDetails?: FinancialDetailsCreateNestedManyWithoutCountryInput
    InternetDetails?: InternetDetailsCreateNestedManyWithoutCountryInput
    EducationDetails?: EducationDetailsCreateNestedManyWithoutCountryInput
    EmploymentDetails?: EmploymentDetailsCreateNestedManyWithoutCountryInput
  }

  export type CountriesUncheckedCreateWithoutVehicleDetailsInput = {
    CountryID?: number
    CountryName: string
    PersonalDetails?: PersonalDetailsUncheckedCreateNestedManyWithoutCountryInput
    FinancialDetails?: FinancialDetailsUncheckedCreateNestedManyWithoutCountryInput
    InternetDetails?: InternetDetailsUncheckedCreateNestedManyWithoutCountryInput
    EducationDetails?: EducationDetailsUncheckedCreateNestedManyWithoutCountryInput
    EmploymentDetails?: EmploymentDetailsUncheckedCreateNestedManyWithoutCountryInput
  }

  export type CountriesCreateOrConnectWithoutVehicleDetailsInput = {
    where: CountriesWhereUniqueInput
    create: XOR<CountriesCreateWithoutVehicleDetailsInput, CountriesUncheckedCreateWithoutVehicleDetailsInput>
  }

  export type CountriesUpsertWithoutVehicleDetailsInput = {
    update: XOR<CountriesUpdateWithoutVehicleDetailsInput, CountriesUncheckedUpdateWithoutVehicleDetailsInput>
    create: XOR<CountriesCreateWithoutVehicleDetailsInput, CountriesUncheckedCreateWithoutVehicleDetailsInput>
    where?: CountriesWhereInput
  }

  export type CountriesUpdateToOneWithWhereWithoutVehicleDetailsInput = {
    where?: CountriesWhereInput
    data: XOR<CountriesUpdateWithoutVehicleDetailsInput, CountriesUncheckedUpdateWithoutVehicleDetailsInput>
  }

  export type CountriesUpdateWithoutVehicleDetailsInput = {
    CountryName?: StringFieldUpdateOperationsInput | string
    PersonalDetails?: PersonalDetailsUpdateManyWithoutCountryNestedInput
    FinancialDetails?: FinancialDetailsUpdateManyWithoutCountryNestedInput
    InternetDetails?: InternetDetailsUpdateManyWithoutCountryNestedInput
    EducationDetails?: EducationDetailsUpdateManyWithoutCountryNestedInput
    EmploymentDetails?: EmploymentDetailsUpdateManyWithoutCountryNestedInput
  }

  export type CountriesUncheckedUpdateWithoutVehicleDetailsInput = {
    CountryID?: IntFieldUpdateOperationsInput | number
    CountryName?: StringFieldUpdateOperationsInput | string
    PersonalDetails?: PersonalDetailsUncheckedUpdateManyWithoutCountryNestedInput
    FinancialDetails?: FinancialDetailsUncheckedUpdateManyWithoutCountryNestedInput
    InternetDetails?: InternetDetailsUncheckedUpdateManyWithoutCountryNestedInput
    EducationDetails?: EducationDetailsUncheckedUpdateManyWithoutCountryNestedInput
    EmploymentDetails?: EmploymentDetailsUncheckedUpdateManyWithoutCountryNestedInput
  }

  export type PersonalDetailsCreateManyCountryInput = {
    ID?: number
    Name?: string | null
    Address?: string | null
    Postcode?: string | null
    City?: string | null
    DateOfBirth?: Date | string | null
    Gender?: string | null
    Phone?: string | null
    MothersMaidenName?: string | null
    Email?: string | null
    Ethnicity?: string | null
    ZodiacSign?: string | null
    Age?: number | null
    Height?: number | null
    Weight?: number | null
    EyeColor?: string | null
    HairColor?: string | null
  }

  export type FinancialDetailsCreateManyCountryInput = {
    ID?: number
    CreditCardType?: string | null
    CreditCardNumber?: string | null
    CreditCardExpiry?: string | null
    CreditCardCVV2?: number | null
  }

  export type InternetDetailsCreateManyCountryInput = {
    ID?: number
    UserName?: string | null
    Password?: string | null
    IPv4Address?: string | null
    IPv6Address?: string | null
    UserAgent?: string | null
  }

  export type EducationDetailsCreateManyCountryInput = {
    ID?: number
    Qualification?: string | null
    Institution?: string | null
  }

  export type EmploymentDetailsCreateManyCountryInput = {
    ID?: number
    CompanyName?: string | null
    Salary?: string | null
    CompanyAddress?: string | null
    JobTitle?: string | null
    CompanyPhone?: string | null
    CompanyEmail?: string | null
  }

  export type VehicleDetailsCreateManyCountryInput = {
    ID?: number
    VehicleName?: string | null
    LicensePlate?: string | null
    VIN?: string | null
    Color?: string | null
  }

  export type PersonalDetailsUpdateWithoutCountryInput = {
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    Postcode?: NullableStringFieldUpdateOperationsInput | string | null
    City?: NullableStringFieldUpdateOperationsInput | string | null
    DateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Gender?: NullableStringFieldUpdateOperationsInput | string | null
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    MothersMaidenName?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Ethnicity?: NullableStringFieldUpdateOperationsInput | string | null
    ZodiacSign?: NullableStringFieldUpdateOperationsInput | string | null
    Age?: NullableIntFieldUpdateOperationsInput | number | null
    Height?: NullableFloatFieldUpdateOperationsInput | number | null
    Weight?: NullableFloatFieldUpdateOperationsInput | number | null
    EyeColor?: NullableStringFieldUpdateOperationsInput | string | null
    HairColor?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PersonalDetailsUncheckedUpdateWithoutCountryInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    Postcode?: NullableStringFieldUpdateOperationsInput | string | null
    City?: NullableStringFieldUpdateOperationsInput | string | null
    DateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Gender?: NullableStringFieldUpdateOperationsInput | string | null
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    MothersMaidenName?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Ethnicity?: NullableStringFieldUpdateOperationsInput | string | null
    ZodiacSign?: NullableStringFieldUpdateOperationsInput | string | null
    Age?: NullableIntFieldUpdateOperationsInput | number | null
    Height?: NullableFloatFieldUpdateOperationsInput | number | null
    Weight?: NullableFloatFieldUpdateOperationsInput | number | null
    EyeColor?: NullableStringFieldUpdateOperationsInput | string | null
    HairColor?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PersonalDetailsUncheckedUpdateManyWithoutCountryInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Name?: NullableStringFieldUpdateOperationsInput | string | null
    Address?: NullableStringFieldUpdateOperationsInput | string | null
    Postcode?: NullableStringFieldUpdateOperationsInput | string | null
    City?: NullableStringFieldUpdateOperationsInput | string | null
    DateOfBirth?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    Gender?: NullableStringFieldUpdateOperationsInput | string | null
    Phone?: NullableStringFieldUpdateOperationsInput | string | null
    MothersMaidenName?: NullableStringFieldUpdateOperationsInput | string | null
    Email?: NullableStringFieldUpdateOperationsInput | string | null
    Ethnicity?: NullableStringFieldUpdateOperationsInput | string | null
    ZodiacSign?: NullableStringFieldUpdateOperationsInput | string | null
    Age?: NullableIntFieldUpdateOperationsInput | number | null
    Height?: NullableFloatFieldUpdateOperationsInput | number | null
    Weight?: NullableFloatFieldUpdateOperationsInput | number | null
    EyeColor?: NullableStringFieldUpdateOperationsInput | string | null
    HairColor?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FinancialDetailsUpdateWithoutCountryInput = {
    CreditCardType?: NullableStringFieldUpdateOperationsInput | string | null
    CreditCardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    CreditCardExpiry?: NullableStringFieldUpdateOperationsInput | string | null
    CreditCardCVV2?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type FinancialDetailsUncheckedUpdateWithoutCountryInput = {
    ID?: IntFieldUpdateOperationsInput | number
    CreditCardType?: NullableStringFieldUpdateOperationsInput | string | null
    CreditCardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    CreditCardExpiry?: NullableStringFieldUpdateOperationsInput | string | null
    CreditCardCVV2?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type FinancialDetailsUncheckedUpdateManyWithoutCountryInput = {
    ID?: IntFieldUpdateOperationsInput | number
    CreditCardType?: NullableStringFieldUpdateOperationsInput | string | null
    CreditCardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    CreditCardExpiry?: NullableStringFieldUpdateOperationsInput | string | null
    CreditCardCVV2?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type InternetDetailsUpdateWithoutCountryInput = {
    UserName?: NullableStringFieldUpdateOperationsInput | string | null
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    IPv4Address?: NullableStringFieldUpdateOperationsInput | string | null
    IPv6Address?: NullableStringFieldUpdateOperationsInput | string | null
    UserAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InternetDetailsUncheckedUpdateWithoutCountryInput = {
    ID?: IntFieldUpdateOperationsInput | number
    UserName?: NullableStringFieldUpdateOperationsInput | string | null
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    IPv4Address?: NullableStringFieldUpdateOperationsInput | string | null
    IPv6Address?: NullableStringFieldUpdateOperationsInput | string | null
    UserAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type InternetDetailsUncheckedUpdateManyWithoutCountryInput = {
    ID?: IntFieldUpdateOperationsInput | number
    UserName?: NullableStringFieldUpdateOperationsInput | string | null
    Password?: NullableStringFieldUpdateOperationsInput | string | null
    IPv4Address?: NullableStringFieldUpdateOperationsInput | string | null
    IPv6Address?: NullableStringFieldUpdateOperationsInput | string | null
    UserAgent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EducationDetailsUpdateWithoutCountryInput = {
    Qualification?: NullableStringFieldUpdateOperationsInput | string | null
    Institution?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EducationDetailsUncheckedUpdateWithoutCountryInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Qualification?: NullableStringFieldUpdateOperationsInput | string | null
    Institution?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EducationDetailsUncheckedUpdateManyWithoutCountryInput = {
    ID?: IntFieldUpdateOperationsInput | number
    Qualification?: NullableStringFieldUpdateOperationsInput | string | null
    Institution?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmploymentDetailsUpdateWithoutCountryInput = {
    CompanyName?: NullableStringFieldUpdateOperationsInput | string | null
    Salary?: NullableStringFieldUpdateOperationsInput | string | null
    CompanyAddress?: NullableStringFieldUpdateOperationsInput | string | null
    JobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    CompanyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    CompanyEmail?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmploymentDetailsUncheckedUpdateWithoutCountryInput = {
    ID?: IntFieldUpdateOperationsInput | number
    CompanyName?: NullableStringFieldUpdateOperationsInput | string | null
    Salary?: NullableStringFieldUpdateOperationsInput | string | null
    CompanyAddress?: NullableStringFieldUpdateOperationsInput | string | null
    JobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    CompanyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    CompanyEmail?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmploymentDetailsUncheckedUpdateManyWithoutCountryInput = {
    ID?: IntFieldUpdateOperationsInput | number
    CompanyName?: NullableStringFieldUpdateOperationsInput | string | null
    Salary?: NullableStringFieldUpdateOperationsInput | string | null
    CompanyAddress?: NullableStringFieldUpdateOperationsInput | string | null
    JobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    CompanyPhone?: NullableStringFieldUpdateOperationsInput | string | null
    CompanyEmail?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VehicleDetailsUpdateWithoutCountryInput = {
    VehicleName?: NullableStringFieldUpdateOperationsInput | string | null
    LicensePlate?: NullableStringFieldUpdateOperationsInput | string | null
    VIN?: NullableStringFieldUpdateOperationsInput | string | null
    Color?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VehicleDetailsUncheckedUpdateWithoutCountryInput = {
    ID?: IntFieldUpdateOperationsInput | number
    VehicleName?: NullableStringFieldUpdateOperationsInput | string | null
    LicensePlate?: NullableStringFieldUpdateOperationsInput | string | null
    VIN?: NullableStringFieldUpdateOperationsInput | string | null
    Color?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type VehicleDetailsUncheckedUpdateManyWithoutCountryInput = {
    ID?: IntFieldUpdateOperationsInput | number
    VehicleName?: NullableStringFieldUpdateOperationsInput | string | null
    LicensePlate?: NullableStringFieldUpdateOperationsInput | string | null
    VIN?: NullableStringFieldUpdateOperationsInput | string | null
    Color?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use CountriesCountOutputTypeDefaultArgs instead
     */
    export type CountriesCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CountriesCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CountriesDefaultArgs instead
     */
    export type CountriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CountriesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PersonalDetailsDefaultArgs instead
     */
    export type PersonalDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PersonalDetailsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FinancialDetailsDefaultArgs instead
     */
    export type FinancialDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FinancialDetailsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InternetDetailsDefaultArgs instead
     */
    export type InternetDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InternetDetailsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EducationDetailsDefaultArgs instead
     */
    export type EducationDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EducationDetailsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmploymentDetailsDefaultArgs instead
     */
    export type EmploymentDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmploymentDetailsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use VehicleDetailsDefaultArgs instead
     */
    export type VehicleDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = VehicleDetailsDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}